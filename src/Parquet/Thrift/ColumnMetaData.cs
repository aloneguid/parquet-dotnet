#pragma warning disable CS1591 // Missing XML comment for publicly visible type or member
/*
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
using System.Collections.Generic;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Thrift.Collections;

using Thrift.Protocol;
using Thrift.Protocol.Entities;
using Thrift.Protocol.Utilities;


namespace Parquet.Thrift
{

   /// <summary>
   /// Description for column metadata
   /// </summary>
   public partial class ColumnMetaData : TBase
  {
    private List<KeyValue> _key_value_metadata;
    private long _index_page_offset;
    private long _dictionary_page_offset;
    private Statistics _statistics;
    private List<PageEncodingStats> _encoding_stats;
    private long _bloom_filter_offset;

    /// <summary>
    /// Type of this column *
    /// 
    /// <seealso cref="Type"/>
    /// </summary>
    public Type Type { get; set; }

    /// <summary>
    /// Set of all encodings used for this column. The purpose is to validate
    /// whether we can decode those pages. *
    /// </summary>
    public List<Encoding> Encodings { get; set; }

    /// <summary>
    /// Path in schema *
    /// </summary>
    public List<string> Path_in_schema { get; set; }

    /// <summary>
    /// Compression codec *
    /// 
    /// <seealso cref="CompressionCodec"/>
    /// </summary>
    public CompressionCodec Codec { get; set; }

    /// <summary>
    /// Number of values in this column *
    /// </summary>
    public long Num_values { get; set; }

    /// <summary>
    /// total byte size of all uncompressed pages in this column chunk (including the headers) *
    /// </summary>
    public long Total_uncompressed_size { get; set; }

    /// <summary>
    /// total byte size of all compressed, and potentially encrypted, pages
    /// in this column chunk (including the headers) *
    /// </summary>
    public long Total_compressed_size { get; set; }

    /// <summary>
    /// Optional key/value metadata *
    /// </summary>
    public List<KeyValue> Key_value_metadata
    {
      get
      {
        return _key_value_metadata;
      }
      set
      {
        __isset.key_value_metadata = true;
        this._key_value_metadata = value;
      }
    }

    /// <summary>
    /// Byte offset from beginning of file to first data page *
    /// </summary>
    public long Data_page_offset { get; set; }

    /// <summary>
    /// Byte offset from beginning of file to root index page *
    /// </summary>
    public long Index_page_offset
    {
      get
      {
        return _index_page_offset;
      }
      set
      {
        __isset.index_page_offset = true;
        this._index_page_offset = value;
      }
    }

    /// <summary>
    /// Byte offset from the beginning of file to first (only) dictionary page *
    /// </summary>
    public long Dictionary_page_offset
    {
      get
      {
        return _dictionary_page_offset;
      }
      set
      {
        __isset.dictionary_page_offset = true;
        this._dictionary_page_offset = value;
      }
    }

    /// <summary>
    /// optional statistics for this column chunk
    /// </summary>
    public Statistics Statistics
    {
      get
      {
        return _statistics;
      }
      set
      {
        __isset.statistics = true;
        this._statistics = value;
      }
    }

    /// <summary>
    /// Set of all encodings used for pages in this column chunk.
    /// This information can be used to determine if all data pages are
    /// dictionary encoded for example *
    /// </summary>
    public List<PageEncodingStats> Encoding_stats
    {
      get
      {
        return _encoding_stats;
      }
      set
      {
        __isset.encoding_stats = true;
        this._encoding_stats = value;
      }
    }

    /// <summary>
    /// Byte offset from beginning of file to Bloom filter data. *
    /// </summary>
    public long Bloom_filter_offset
    {
      get
      {
        return _bloom_filter_offset;
      }
      set
      {
        __isset.bloom_filter_offset = true;
        this._bloom_filter_offset = value;
      }
    }


    public Isset __isset;
    public struct Isset
    {
      public bool key_value_metadata;
      public bool index_page_offset;
      public bool dictionary_page_offset;
      public bool statistics;
      public bool encoding_stats;
      public bool bloom_filter_offset;
    }

    public ColumnMetaData()
    {
    }

    public ColumnMetaData(Type type, List<Encoding> encodings, List<string> path_in_schema, CompressionCodec codec, long num_values, long total_uncompressed_size, long total_compressed_size, long data_page_offset) : this()
    {
      this.Type = type;
      this.Encodings = encodings;
      this.Path_in_schema = path_in_schema;
      this.Codec = codec;
      this.Num_values = num_values;
      this.Total_uncompressed_size = total_uncompressed_size;
      this.Total_compressed_size = total_compressed_size;
      this.Data_page_offset = data_page_offset;
    }

    public async Task ReadAsync(TProtocol iprot, CancellationToken cancellationToken)
    {
      iprot.IncrementRecursionDepth();
      try
      {
        bool isset_type = false;
        bool isset_encodings = false;
        bool isset_path_in_schema = false;
        bool isset_codec = false;
        bool isset_num_values = false;
        bool isset_total_uncompressed_size = false;
        bool isset_total_compressed_size = false;
        bool isset_data_page_offset = false;
        TField field;
        await iprot.ReadStructBeginAsync(cancellationToken);
        while (true)
        {
          field = await iprot.ReadFieldBeginAsync(cancellationToken);
          if (field.Type == TType.Stop)
          {
            break;
          }

          switch (field.ID)
          {
            case 1:
              if (field.Type == TType.I32)
              {
                Type = (Type)await iprot.ReadI32Async(cancellationToken);
                isset_type = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 2:
              if (field.Type == TType.List)
              {
                {
                  TList _list0 = await iprot.ReadListBeginAsync(cancellationToken);
                  Encodings = new List<Encoding>(_list0.Count);
                  for(int _i1 = 0; _i1 < _list0.Count; ++_i1)
                  {
                    Encoding _elem2;
                    _elem2 = (Encoding)await iprot.ReadI32Async(cancellationToken);
                    Encodings.Add(_elem2);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
                isset_encodings = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 3:
              if (field.Type == TType.List)
              {
                {
                  TList _list3 = await iprot.ReadListBeginAsync(cancellationToken);
                  Path_in_schema = new List<string>(_list3.Count);
                  for(int _i4 = 0; _i4 < _list3.Count; ++_i4)
                  {
                    string _elem5;
                    _elem5 = await iprot.ReadStringAsync(cancellationToken);
                    Path_in_schema.Add(_elem5);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
                isset_path_in_schema = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 4:
              if (field.Type == TType.I32)
              {
                Codec = (CompressionCodec)await iprot.ReadI32Async(cancellationToken);
                isset_codec = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 5:
              if (field.Type == TType.I64)
              {
                Num_values = await iprot.ReadI64Async(cancellationToken);
                isset_num_values = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 6:
              if (field.Type == TType.I64)
              {
                Total_uncompressed_size = await iprot.ReadI64Async(cancellationToken);
                isset_total_uncompressed_size = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 7:
              if (field.Type == TType.I64)
              {
                Total_compressed_size = await iprot.ReadI64Async(cancellationToken);
                isset_total_compressed_size = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 8:
              if (field.Type == TType.List)
              {
                {
                  TList _list6 = await iprot.ReadListBeginAsync(cancellationToken);
                  Key_value_metadata = new List<KeyValue>(_list6.Count);
                  for(int _i7 = 0; _i7 < _list6.Count; ++_i7)
                  {
                    KeyValue _elem8;
                    _elem8 = new KeyValue();
                    await _elem8.ReadAsync(iprot, cancellationToken);
                    Key_value_metadata.Add(_elem8);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 9:
              if (field.Type == TType.I64)
              {
                Data_page_offset = await iprot.ReadI64Async(cancellationToken);
                isset_data_page_offset = true;
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 10:
              if (field.Type == TType.I64)
              {
                Index_page_offset = await iprot.ReadI64Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 11:
              if (field.Type == TType.I64)
              {
                Dictionary_page_offset = await iprot.ReadI64Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 12:
              if (field.Type == TType.Struct)
              {
                Statistics = new Statistics();
                await Statistics.ReadAsync(iprot, cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 13:
              if (field.Type == TType.List)
              {
                {
                  TList _list9 = await iprot.ReadListBeginAsync(cancellationToken);
                  Encoding_stats = new List<PageEncodingStats>(_list9.Count);
                  for(int _i10 = 0; _i10 < _list9.Count; ++_i10)
                  {
                    PageEncodingStats _elem11;
                    _elem11 = new PageEncodingStats();
                    await _elem11.ReadAsync(iprot, cancellationToken);
                    Encoding_stats.Add(_elem11);
                  }
                  await iprot.ReadListEndAsync(cancellationToken);
                }
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            case 14:
              if (field.Type == TType.I64)
              {
                Bloom_filter_offset = await iprot.ReadI64Async(cancellationToken);
              }
              else
              {
                await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              }
              break;
            default: 
              await TProtocolUtil.SkipAsync(iprot, field.Type, cancellationToken);
              break;
          }

          await iprot.ReadFieldEndAsync(cancellationToken);
        }

        await iprot.ReadStructEndAsync(cancellationToken);
        if (!isset_type)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_encodings)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_path_in_schema)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_codec)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_num_values)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_total_uncompressed_size)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_total_compressed_size)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
        if (!isset_data_page_offset)
        {
          throw new TProtocolException(TProtocolException.INVALID_DATA);
        }
      }
      finally
      {
        iprot.DecrementRecursionDepth();
      }
    }

    public async Task WriteAsync(TProtocol oprot, CancellationToken cancellationToken)
    {
      oprot.IncrementRecursionDepth();
      try
      {
        var struc = new TStruct("ColumnMetaData");
        await oprot.WriteStructBeginAsync(struc, cancellationToken);
        var field = new TField();
        field.Name = "type";
        field.Type = TType.I32;
        field.ID = 1;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteI32Async((int)Type, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "encodings";
        field.Type = TType.List;
        field.ID = 2;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        {
          await oprot.WriteListBeginAsync(new TList(TType.I32, Encodings.Count), cancellationToken);
          foreach (Encoding _iter12 in Encodings)
          {
            await oprot.WriteI32Async((int)_iter12, cancellationToken);
          }
          await oprot.WriteListEndAsync(cancellationToken);
        }
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "path_in_schema";
        field.Type = TType.List;
        field.ID = 3;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        {
          await oprot.WriteListBeginAsync(new TList(TType.String, Path_in_schema.Count), cancellationToken);
          foreach (string _iter13 in Path_in_schema)
          {
            await oprot.WriteStringAsync(_iter13, cancellationToken);
          }
          await oprot.WriteListEndAsync(cancellationToken);
        }
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "codec";
        field.Type = TType.I32;
        field.ID = 4;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteI32Async((int)Codec, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "num_values";
        field.Type = TType.I64;
        field.ID = 5;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteI64Async(Num_values, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "total_uncompressed_size";
        field.Type = TType.I64;
        field.ID = 6;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteI64Async(Total_uncompressed_size, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        field.Name = "total_compressed_size";
        field.Type = TType.I64;
        field.ID = 7;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteI64Async(Total_compressed_size, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if (Key_value_metadata != null && __isset.key_value_metadata)
        {
          field.Name = "key_value_metadata";
          field.Type = TType.List;
          field.ID = 8;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Key_value_metadata.Count), cancellationToken);
            foreach (KeyValue _iter14 in Key_value_metadata)
            {
              await _iter14.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        field.Name = "data_page_offset";
        field.Type = TType.I64;
        field.ID = 9;
        await oprot.WriteFieldBeginAsync(field, cancellationToken);
        await oprot.WriteI64Async(Data_page_offset, cancellationToken);
        await oprot.WriteFieldEndAsync(cancellationToken);
        if (__isset.index_page_offset)
        {
          field.Name = "index_page_offset";
          field.Type = TType.I64;
          field.ID = 10;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteI64Async(Index_page_offset, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if (__isset.dictionary_page_offset)
        {
          field.Name = "dictionary_page_offset";
          field.Type = TType.I64;
          field.ID = 11;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteI64Async(Dictionary_page_offset, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if (Statistics != null && __isset.statistics)
        {
          field.Name = "statistics";
          field.Type = TType.Struct;
          field.ID = 12;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await Statistics.WriteAsync(oprot, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if (Encoding_stats != null && __isset.encoding_stats)
        {
          field.Name = "encoding_stats";
          field.Type = TType.List;
          field.ID = 13;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          {
            await oprot.WriteListBeginAsync(new TList(TType.Struct, Encoding_stats.Count), cancellationToken);
            foreach (PageEncodingStats _iter15 in Encoding_stats)
            {
              await _iter15.WriteAsync(oprot, cancellationToken);
            }
            await oprot.WriteListEndAsync(cancellationToken);
          }
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        if (__isset.bloom_filter_offset)
        {
          field.Name = "bloom_filter_offset";
          field.Type = TType.I64;
          field.ID = 14;
          await oprot.WriteFieldBeginAsync(field, cancellationToken);
          await oprot.WriteI64Async(Bloom_filter_offset, cancellationToken);
          await oprot.WriteFieldEndAsync(cancellationToken);
        }
        await oprot.WriteFieldStopAsync(cancellationToken);
        await oprot.WriteStructEndAsync(cancellationToken);
      }
      finally
      {
        oprot.DecrementRecursionDepth();
      }
    }

    public override bool Equals(object that)
    {
      var other = that as ColumnMetaData;
      if (other == null) return false;
      if (ReferenceEquals(this, other)) return true;
      return System.Object.Equals(Type, other.Type)
        && TCollections.Equals(Encodings, other.Encodings)
        && TCollections.Equals(Path_in_schema, other.Path_in_schema)
        && System.Object.Equals(Codec, other.Codec)
        && System.Object.Equals(Num_values, other.Num_values)
        && System.Object.Equals(Total_uncompressed_size, other.Total_uncompressed_size)
        && System.Object.Equals(Total_compressed_size, other.Total_compressed_size)
        && ((__isset.key_value_metadata == other.__isset.key_value_metadata) && ((!__isset.key_value_metadata) || (TCollections.Equals(Key_value_metadata, other.Key_value_metadata))))
        && System.Object.Equals(Data_page_offset, other.Data_page_offset)
        && ((__isset.index_page_offset == other.__isset.index_page_offset) && ((!__isset.index_page_offset) || (System.Object.Equals(Index_page_offset, other.Index_page_offset))))
        && ((__isset.dictionary_page_offset == other.__isset.dictionary_page_offset) && ((!__isset.dictionary_page_offset) || (System.Object.Equals(Dictionary_page_offset, other.Dictionary_page_offset))))
        && ((__isset.statistics == other.__isset.statistics) && ((!__isset.statistics) || (System.Object.Equals(Statistics, other.Statistics))))
        && ((__isset.encoding_stats == other.__isset.encoding_stats) && ((!__isset.encoding_stats) || (TCollections.Equals(Encoding_stats, other.Encoding_stats))))
        && ((__isset.bloom_filter_offset == other.__isset.bloom_filter_offset) && ((!__isset.bloom_filter_offset) || (System.Object.Equals(Bloom_filter_offset, other.Bloom_filter_offset))));
    }

    public override int GetHashCode() {
      int hashcode = 157;
      unchecked {
        hashcode = (hashcode * 397) + Type.GetHashCode();
        hashcode = (hashcode * 397) + TCollections.GetHashCode(Encodings);
        hashcode = (hashcode * 397) + TCollections.GetHashCode(Path_in_schema);
        hashcode = (hashcode * 397) + Codec.GetHashCode();
        hashcode = (hashcode * 397) + Num_values.GetHashCode();
        hashcode = (hashcode * 397) + Total_uncompressed_size.GetHashCode();
        hashcode = (hashcode * 397) + Total_compressed_size.GetHashCode();
        if(__isset.key_value_metadata)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Key_value_metadata);
        hashcode = (hashcode * 397) + Data_page_offset.GetHashCode();
        if(__isset.index_page_offset)
          hashcode = (hashcode * 397) + Index_page_offset.GetHashCode();
        if(__isset.dictionary_page_offset)
          hashcode = (hashcode * 397) + Dictionary_page_offset.GetHashCode();
        if(__isset.statistics)
          hashcode = (hashcode * 397) + Statistics.GetHashCode();
        if(__isset.encoding_stats)
          hashcode = (hashcode * 397) + TCollections.GetHashCode(Encoding_stats);
        if(__isset.bloom_filter_offset)
          hashcode = (hashcode * 397) + Bloom_filter_offset.GetHashCode();
      }
      return hashcode;
    }

    public override string ToString()
    {
      var sb = new StringBuilder("ColumnMetaData(");
      sb.Append(", Type: ");
      sb.Append(Type);
      sb.Append(", Encodings: ");
      sb.Append(Encodings);
      sb.Append(", Path_in_schema: ");
      sb.Append(Path_in_schema);
      sb.Append(", Codec: ");
      sb.Append(Codec);
      sb.Append(", Num_values: ");
      sb.Append(Num_values);
      sb.Append(", Total_uncompressed_size: ");
      sb.Append(Total_uncompressed_size);
      sb.Append(", Total_compressed_size: ");
      sb.Append(Total_compressed_size);
      if (Key_value_metadata != null && __isset.key_value_metadata)
      {
        sb.Append(", Key_value_metadata: ");
        sb.Append(Key_value_metadata);
      }
      sb.Append(", Data_page_offset: ");
      sb.Append(Data_page_offset);
      if (__isset.index_page_offset)
      {
        sb.Append(", Index_page_offset: ");
        sb.Append(Index_page_offset);
      }
      if (__isset.dictionary_page_offset)
      {
        sb.Append(", Dictionary_page_offset: ");
        sb.Append(Dictionary_page_offset);
      }
      if (Statistics != null && __isset.statistics)
      {
        sb.Append(", Statistics: ");
        sb.Append(Statistics== null ? "<null>" : Statistics.ToString());
      }
      if (Encoding_stats != null && __isset.encoding_stats)
      {
        sb.Append(", Encoding_stats: ");
        sb.Append(Encoding_stats);
      }
      if (__isset.bloom_filter_offset)
      {
        sb.Append(", Bloom_filter_offset: ");
        sb.Append(Bloom_filter_offset);
      }
      sb.Append(")");
      return sb.ToString();
    }
  }

}
#pragma warning restore CS1591 // Missing XML comment for publicly visible type or member
