<idl>
  <!-- 
 * Autogenerated by Thrift Compiler (0.16.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 -->
  <document name="parquet" doc="Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
&quot;License&quot;); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
&quot;AS IS&quot; BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.">
    <namespace name="cpp" value="parquet" />
    <namespace name="java" value="org.apache.parquet.format" />
    <enum name="Type" doc="Types supported by Parquet.  These types are intended to be used in combination
with the encodings to control the on disk storage format.
For example INT16 is not included as a type since a good encoding of INT32
would handle this.">
      <member name="BOOLEAN" value="0" />
      <member name="INT32" value="1" />
      <member name="INT64" value="2" />
      <member name="INT96" value="3" />
      <member name="FLOAT" value="4" />
      <member name="DOUBLE" value="5" />
      <member name="BYTE_ARRAY" value="6" />
      <member name="FIXED_LEN_BYTE_ARRAY" value="7" />
    </enum>
    <enum name="ConvertedType" doc="DEPRECATED: Common types used by frameworks(e.g. hive, pig) using parquet.
ConvertedType is superseded by LogicalType.  This enum should not be extended.

See LogicalTypes.md for conversion between ConvertedType and LogicalType.">
      <member name="UTF8" value="0" doc="a BYTE_ARRAY actually contains UTF8 encoded chars" />
      <member name="MAP" value="1" doc="a map is converted as an optional field containing a repeated key/value pair" />
      <member name="MAP_KEY_VALUE" value="2" doc="a key/value pair is converted into a group of two fields" />
      <member name="LIST" value="3" doc="a list is converted into an optional field containing a repeated field for its
values" />
      <member name="ENUM" value="4" doc="an enum is converted into a BYTE_ARRAY field" />
      <member name="DECIMAL" value="5" doc="A decimal value.

This may be used to annotate BYTE_ARRAY or FIXED_LEN_BYTE_ARRAY primitive
types. The underlying byte array stores the unscaled value encoded as two&apos;s
complement using big-endian byte order (the most significant byte is the
zeroth element). The value of the decimal is the value * 10^{-scale}.

This must be accompanied by a (maximum) precision and a scale in the
SchemaElement. The precision specifies the number of digits in the decimal
and the scale stores the location of the decimal point. For example 1.23
would have precision 3 (3 total digits) and scale 2 (the decimal point is
2 digits over)." />
      <member name="DATE" value="6" doc="A Date

Stored as days since Unix epoch, encoded as the INT32 physical type." />
      <member name="TIME_MILLIS" value="7" doc="A time

The total number of milliseconds since midnight.  The value is stored
as an INT32 physical type." />
      <member name="TIME_MICROS" value="8" doc="A time.

The total number of microseconds since midnight.  The value is stored as
an INT64 physical type." />
      <member name="TIMESTAMP_MILLIS" value="9" doc="A date/time combination

Date and time recorded as milliseconds since the Unix epoch.  Recorded as
a physical type of INT64." />
      <member name="TIMESTAMP_MICROS" value="10" doc="A date/time combination

Date and time recorded as microseconds since the Unix epoch.  The value is
stored as an INT64 physical type." />
      <member name="UINT_8" value="11" doc="An unsigned integer value.

The number describes the maximum number of meaningful data bits in
the stored value. 8, 16 and 32 bit values are stored using the
INT32 physical type.  64 bit values are stored using the INT64
physical type." />
      <member name="UINT_16" value="12" />
      <member name="UINT_32" value="13" />
      <member name="UINT_64" value="14" />
      <member name="INT_8" value="15" doc="A signed integer value.

The number describes the maximum number of meaningful data bits in
the stored value. 8, 16 and 32 bit values are stored using the
INT32 physical type.  64 bit values are stored using the INT64
physical type." />
      <member name="INT_16" value="16" />
      <member name="INT_32" value="17" />
      <member name="INT_64" value="18" />
      <member name="JSON" value="19" doc="An embedded JSON document

A JSON document embedded within a single UTF8 column." />
      <member name="BSON" value="20" doc="An embedded BSON document

A BSON document embedded within a single BYTE_ARRAY column." />
      <member name="INTERVAL" value="21" doc="An interval of time

This type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12
This data is composed of three separate little endian unsigned
integers.  Each stores a component of a duration of time.  The first
integer identifies the number of months associated with the duration,
the second identifies the number of days associated with the duration
and the third identifies the number of milliseconds associated with
the provided duration.  This duration of time is independent of any
particular timezone or date." />
    </enum>
    <enum name="FieldRepetitionType" doc="Representation of Schemas">
      <member name="REQUIRED" value="0" doc="This field is required (can not be null) and each row has exactly 1 value." />
      <member name="OPTIONAL" value="1" doc="The field is optional (can be null) and each row has 0 or 1 values." />
      <member name="REPEATED" value="2" doc="The field is repeated and can contain 0 or more values" />
    </enum>
    <enum name="Encoding" doc="Encodings supported by Parquet.  Not all encodings are valid for all types.  These
enums are also used to specify the encoding of definition and repetition levels.
See the accompanying doc for the details of the more complicated encodings.">
      <member name="PLAIN" value="0" doc="Default encoding.
BOOLEAN - 1 bit per value. 0 is false; 1 is true.
INT32 - 4 bytes per value.  Stored as little-endian.
INT64 - 8 bytes per value.  Stored as little-endian.
FLOAT - 4 bytes per value.  IEEE. Stored as little-endian.
DOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.
BYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.
FIXED_LEN_BYTE_ARRAY - Just the bytes." />
      <member name="PLAIN_DICTIONARY" value="2" doc="Deprecated: Dictionary encoding. The values in the dictionary are encoded in the
plain type.
in a data page use RLE_DICTIONARY instead.
in a Dictionary page use PLAIN instead" />
      <member name="RLE" value="3" doc="Group packed run length encoding. Usable for definition/repetition levels
encoding and Booleans (on one bit: 0 is false; 1 is true.)" />
      <member name="BIT_PACKED" value="4" doc="Bit packed encoding.  This can only be used if the data has a known max
width.  Usable for definition/repetition levels encoding." />
      <member name="DELTA_BINARY_PACKED" value="5" doc="Delta encoding for integers. This can be used for int columns and works best
on sorted data" />
      <member name="DELTA_LENGTH_BYTE_ARRAY" value="6" doc="Encoding for byte arrays to separate the length values and the data. The lengths
are encoded using DELTA_BINARY_PACKED" />
      <member name="DELTA_BYTE_ARRAY" value="7" doc="Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.
Suffixes are stored as delta length byte arrays." />
      <member name="RLE_DICTIONARY" value="8" doc="Dictionary encoding: the ids are encoded using the RLE encoding" />
      <member name="BYTE_STREAM_SPLIT" value="9" doc="Encoding for fixed-width data (FLOAT, DOUBLE, INT32, INT64, FIXED_LEN_BYTE_ARRAY).
K byte-streams are created where K is the size in bytes of the data type.
The individual bytes of a value are scattered to the corresponding stream and
the streams are concatenated.
This itself does not reduce the size of the data but can lead to better compression
afterwards.

Added in 2.8 for FLOAT and DOUBLE.
Support for INT32, INT64 and FIXED_LEN_BYTE_ARRAY added in 2.11." />
    </enum>
    <enum name="CompressionCodec" doc="Supported compression algorithms.

Codecs added in format version X.Y can be read by readers based on X.Y and later.
Codec support may vary between readers based on the format version and
libraries available at runtime.

See Compression.md for a detailed specification of these algorithms.">
      <member name="UNCOMPRESSED" value="0" />
      <member name="SNAPPY" value="1" />
      <member name="GZIP" value="2" />
      <member name="LZO" value="3" />
      <member name="BROTLI" value="4" />
      <member name="LZ4" value="5" />
      <member name="ZSTD" value="6" />
      <member name="LZ4_RAW" value="7" />
    </enum>
    <enum name="PageType">
      <member name="DATA_PAGE" value="0" />
      <member name="INDEX_PAGE" value="1" />
      <member name="DICTIONARY_PAGE" value="2" />
      <member name="DATA_PAGE_V2" value="3" />
    </enum>
    <enum name="BoundaryOrder" doc="Enum to annotate whether lists of min/max elements inside ColumnIndex
are ordered and if so, in which direction.">
      <member name="UNORDERED" value="0" />
      <member name="ASCENDING" value="1" />
      <member name="DESCENDING" value="2" />
    </enum>
    <struct name="SizeStatistics" doc="A structure for capturing metadata for estimating the unencoded,
uncompressed size of data written. This is useful for readers to estimate
how much memory is needed to reconstruct data in their memory model and for
fine grained filter pushdown on nested structures (the histograms contained
in this structure can help determine the number of nulls at a particular
nesting level and maximum length of lists).">
      <field name="unencoded_byte_array_data_bytes" field-id="1" doc="The number of physical bytes stored for BYTE_ARRAY data values assuming
no encoding. This is exclusive of the bytes needed to store the length of
each byte array. In other words, this field is equivalent to the `(size
of PLAIN-ENCODING the byte array values) - (4 bytes * number of values
written)`. To determine unencoded sizes of other types readers can use
schema information multiplied by the number of non-null and null values.
The number of null/non-null values can be inferred from the histograms
below.

For example, if a column chunk is dictionary-encoded with dictionary
[&quot;a&quot;, &quot;bc&quot;, &quot;cde&quot;], and a data page contains the indices [0, 0, 1, 2],
then this value for that data page should be 7 (1 + 1 + 2 + 3).

This field should only be set for types that use BYTE_ARRAY as their
physical type." required="optional" type="i64" />
      <field name="repetition_level_histogram" field-id="2" doc="When present, there is expected to be one element corresponding to each
repetition (i.e. size=max repetition_level+1) where each element
represents the number of times the repetition level was observed in the
data.

This field may be omitted if max_repetition_level is 0 without loss
of information." required="optional" type="list">
        <elemType type="i64" />
      </field>
      <field name="definition_level_histogram" field-id="3" doc="Same as repetition_level_histogram except for definition levels.

This field may be omitted if max_definition_level is 0 or 1 without
loss of information." required="optional" type="list">
        <elemType type="i64" />
      </field>
    </struct>
    <struct name="Statistics" doc="Statistics per row group and per page
All fields are optional.">
      <field name="max" field-id="1" doc="DEPRECATED: min and max value of the column. Use min_value and max_value.

Values are encoded using PLAIN encoding, except that variable-length byte
arrays do not include a length prefix.

These fields encode min and max values determined by signed comparison
only. New files should use the correct order for a column&apos;s logical type
and store the values in the min_value and max_value fields.

To support older readers, these may be set when the column order is
signed." required="optional" type="binary" />
      <field name="min" field-id="2" required="optional" type="binary" />
      <field name="null_count" field-id="3" doc="Count of null values in the column.

Writers SHOULD always write this field even if it is zero (i.e. no null value)
or the column is not nullable.
Readers MUST distinguish between null_count not being present and null_count == 0.
If null_count is not present, readers MUST NOT assume null_count == 0." required="optional" type="i64" />
      <field name="distinct_count" field-id="4" doc="count of distinct values occurring" required="optional" type="i64" />
      <field name="max_value" field-id="5" doc="Lower and upper bound values for the column, determined by its ColumnOrder.

These may be the actual minimum and maximum values found on a page or column
chunk, but can also be (more compact) values that do not exist on a page or
column chunk. For example, instead of storing &quot;Blart Versenwald III&quot;, a writer
may set min_value=&quot;B&quot;, max_value=&quot;C&quot;. Such more compact values must still be
valid values within the column&apos;s logical type.

Values are encoded using PLAIN encoding, except that variable-length byte
arrays do not include a length prefix." required="optional" type="binary" />
      <field name="min_value" field-id="6" required="optional" type="binary" />
      <field name="is_max_value_exact" field-id="7" doc="If true, max_value is the actual maximum value for a column" required="optional" type="bool" />
      <field name="is_min_value_exact" field-id="8" doc="If true, min_value is the actual minimum value for a column" required="optional" type="bool" />
    </struct>
    <struct name="StringType" doc="Empty structs to use as logical type annotations" />
    <struct name="UUIDType" />
    <struct name="MapType" />
    <struct name="ListType" />
    <struct name="EnumType" />
    <struct name="DateType" />
    <struct name="Float16Type" />
    <struct name="NullType" doc="Logical type to annotate a column that is always null.

Sometimes when discovering the schema of existing data, values are always
null and the physical type can&apos;t be determined. This annotation signals
the case where the physical type was guessed from all null values." />
    <struct name="DecimalType" doc="Decimal logical type annotation

Scale must be zero or a positive integer less than or equal to the precision.
Precision must be a non-zero positive integer.

To maintain forward-compatibility in v1, implementations using this logical
type must also set scale and precision on the annotated SchemaElement.

Allowed for physical types: INT32, INT64, FIXED_LEN_BYTE_ARRAY, and BYTE_ARRAY.">
      <field name="scale" field-id="1" required="required" type="i32" />
      <field name="precision" field-id="2" required="required" type="i32" />
    </struct>
    <struct name="MilliSeconds" doc="Time units for logical types" />
    <struct name="MicroSeconds" />
    <struct name="NanoSeconds" />
    <union name="TimeUnit">
      <field name="MILLIS" field-id="1" required="optional" type="id" type-module="parquet" type-id="MilliSeconds" />
      <field name="MICROS" field-id="2" required="optional" type="id" type-module="parquet" type-id="MicroSeconds" />
      <field name="NANOS" field-id="3" required="optional" type="id" type-module="parquet" type-id="NanoSeconds" />
    </union>
    <struct name="TimestampType" doc="Timestamp logical type annotation

Allowed for physical types: INT64">
      <field name="isAdjustedToUTC" field-id="1" required="required" type="bool" />
      <field name="unit" field-id="2" required="required" type="id" type-module="parquet" type-id="TimeUnit" />
    </struct>
    <struct name="TimeType" doc="Time logical type annotation

Allowed for physical types: INT32 (millis), INT64 (micros, nanos)">
      <field name="isAdjustedToUTC" field-id="1" required="required" type="bool" />
      <field name="unit" field-id="2" required="required" type="id" type-module="parquet" type-id="TimeUnit" />
    </struct>
    <struct name="IntType" doc="Integer logical type annotation

bitWidth must be 8, 16, 32, or 64.

Allowed for physical types: INT32, INT64">
      <field name="bitWidth" field-id="1" required="required" type="i8" />
      <field name="isSigned" field-id="2" required="required" type="bool" />
    </struct>
    <struct name="JsonType" doc="Embedded JSON logical type annotation

Allowed for physical types: BYTE_ARRAY" />
    <struct name="BsonType" doc="Embedded BSON logical type annotation

Allowed for physical types: BYTE_ARRAY" />
    <struct name="VariantType" doc="Embedded Variant logical type annotation" />
    <union name="LogicalType" doc="LogicalType annotations to replace ConvertedType.

To maintain compatibility, implementations using LogicalType for a
SchemaElement must also set the corresponding ConvertedType (if any)
from the following table.">
      <field name="STRING" field-id="1" required="optional" type="id" type-module="parquet" type-id="StringType" />
      <field name="MAP" field-id="2" required="optional" type="id" type-module="parquet" type-id="MapType" />
      <field name="LIST" field-id="3" required="optional" type="id" type-module="parquet" type-id="ListType" />
      <field name="ENUM" field-id="4" required="optional" type="id" type-module="parquet" type-id="EnumType" />
      <field name="DECIMAL" field-id="5" required="optional" type="id" type-module="parquet" type-id="DecimalType" />
      <field name="DATE" field-id="6" required="optional" type="id" type-module="parquet" type-id="DateType" />
      <field name="TIME" field-id="7" required="optional" type="id" type-module="parquet" type-id="TimeType" />
      <field name="TIMESTAMP" field-id="8" required="optional" type="id" type-module="parquet" type-id="TimestampType" />
      <field name="INTEGER" field-id="10" required="optional" type="id" type-module="parquet" type-id="IntType" />
      <field name="UNKNOWN" field-id="11" required="optional" type="id" type-module="parquet" type-id="NullType" />
      <field name="JSON" field-id="12" required="optional" type="id" type-module="parquet" type-id="JsonType" />
      <field name="BSON" field-id="13" required="optional" type="id" type-module="parquet" type-id="BsonType" />
      <field name="UUID" field-id="14" required="optional" type="id" type-module="parquet" type-id="UUIDType" />
      <field name="FLOAT16" field-id="15" required="optional" type="id" type-module="parquet" type-id="Float16Type" />
      <field name="VARIANT" field-id="16" required="optional" type="id" type-module="parquet" type-id="VariantType" />
    </union>
    <struct name="SchemaElement" doc="Represents a element inside a schema definition.
 - if it is a group (inner node) then type is undefined and num_children is defined
 - if it is a primitive type (leaf) then type is defined and num_children is undefined
the nodes are listed in depth first traversal order.">
      <field name="type" field-id="1" doc="Data type for this field. Not set if the current element is a non-leaf node" required="optional" type="id" type-module="parquet" type-id="Type" />
      <field name="type_length" field-id="2" doc="If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the values.
Otherwise, if specified, this is the maximum bit length to store any of the values.
(e.g. a low cardinality INT col could have this set to 3).  Note that this is
in the schema, and therefore fixed for the entire file." required="optional" type="i32" />
      <field name="repetition_type" field-id="3" doc="repetition of the field. The root of the schema does not have a repetition_type.
All other nodes must have one" required="optional" type="id" type-module="parquet" type-id="FieldRepetitionType" />
      <field name="name" field-id="4" doc="Name of the field in the schema" required="required" type="string" />
      <field name="num_children" field-id="5" doc="Nested fields.  Since thrift does not support nested fields,
the nesting is flattened to a single list by a depth-first traversal.
The children count is used to construct the nested relationship.
This field is not set when the element is a primitive type" required="optional" type="i32" />
      <field name="converted_type" field-id="6" doc="DEPRECATED: When the schema is the result of a conversion from another model.
Used to record the original type to help with cross conversion.

This is superseded by logicalType." required="optional" type="id" type-module="parquet" type-id="ConvertedType" />
      <field name="scale" field-id="7" doc="DEPRECATED: Used when this column contains decimal data.
See the DECIMAL converted type for more details.

This is superseded by using the DecimalType annotation in logicalType." required="optional" type="i32" />
      <field name="precision" field-id="8" required="optional" type="i32" />
      <field name="field_id" field-id="9" doc="When the original schema supports field ids, this will save the
original field id in the parquet schema" required="optional" type="i32" />
      <field name="logicalType" field-id="10" doc="The logical type of this SchemaElement

LogicalType replaces ConvertedType, but ConvertedType is still required
for some logical types to ensure forward-compatibility in format v1." required="optional" type="id" type-module="parquet" type-id="LogicalType" />
    </struct>
    <struct name="DataPageHeader" doc="Data page header">
      <field name="num_values" field-id="1" doc="Number of values, including NULLs, in this data page.

If a OffsetIndex is present, a page must begin at a row
boundary (repetition_level = 0). Otherwise, pages may begin
within a row (repetition_level &gt; 0)." required="required" type="i32" />
      <field name="encoding" field-id="2" doc="Encoding used for this data page *" required="required" type="id" type-module="parquet" type-id="Encoding" />
      <field name="definition_level_encoding" field-id="3" doc="Encoding used for definition levels *" required="required" type="id" type-module="parquet" type-id="Encoding" />
      <field name="repetition_level_encoding" field-id="4" doc="Encoding used for repetition levels *" required="required" type="id" type-module="parquet" type-id="Encoding" />
      <field name="statistics" field-id="5" doc="Optional statistics for the data in this page *" required="optional" type="id" type-module="parquet" type-id="Statistics" />
    </struct>
    <struct name="IndexPageHeader" />
    <struct name="DictionaryPageHeader" doc="The dictionary page must be placed at the first position of the column chunk
if it is partly or completely dictionary encoded. At most one dictionary page
can be placed in a column chunk.">
      <field name="num_values" field-id="1" doc="Number of values in the dictionary *" required="required" type="i32" />
      <field name="encoding" field-id="2" doc="Encoding using this dictionary page *" required="required" type="id" type-module="parquet" type-id="Encoding" />
      <field name="is_sorted" field-id="3" doc="If true, the entries in the dictionary are sorted in ascending order *" required="optional" type="bool" />
    </struct>
    <struct name="DataPageHeaderV2" doc="New page format allowing reading levels without decompressing the data
Repetition and definition levels are uncompressed
The remaining section containing the data is compressed if is_compressed is true">
      <field name="num_values" field-id="1" doc="Number of values, including NULLs, in this data page. *" required="required" type="i32" />
      <field name="num_nulls" field-id="2" doc="Number of NULL values, in this data page.
Number of non-null = num_values - num_nulls which is also the number of values in the data section *" required="required" type="i32" />
      <field name="num_rows" field-id="3" doc="Number of rows in this data page. Every page must begin at a
row boundary (repetition_level = 0): rows must **not** be
split across page boundaries when using V2 data pages." required="required" type="i32" />
      <field name="encoding" field-id="4" doc="Encoding used for data in this page *" required="required" type="id" type-module="parquet" type-id="Encoding" />
      <field name="definition_levels_byte_length" field-id="5" doc="Length of the definition levels" required="required" type="i32" />
      <field name="repetition_levels_byte_length" field-id="6" doc="Length of the repetition levels" required="required" type="i32" />
      <field name="is_compressed" field-id="7" doc="Whether the values are compressed.
Which means the section of the page between
definition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)
is compressed with the compression_codec.
If missing it is considered compressed" required="optional" type="bool">
        <default>
          <int>1</int>
        </default>
      </field>
      <field name="statistics" field-id="8" doc="Optional statistics for the data in this page *" required="optional" type="id" type-module="parquet" type-id="Statistics" />
    </struct>
    <struct name="SplitBlockAlgorithm" doc="Block-based algorithm type annotation. *" />
    <union name="BloomFilterAlgorithm" doc="The algorithm used in Bloom filter. *">
      <field name="BLOCK" field-id="1" doc="Block-based Bloom filter. *" required="optional" type="id" type-module="parquet" type-id="SplitBlockAlgorithm" />
    </union>
    <struct name="XxHash" doc="Hash strategy type annotation. xxHash is an extremely fast non-cryptographic hash
algorithm. It uses 64 bits version of xxHash." />
    <union name="BloomFilterHash" doc="The hash function used in Bloom filter. This function takes the hash of a column value
using plain encoding.">
      <field name="XXHASH" field-id="1" doc="xxHash Strategy. *" required="optional" type="id" type-module="parquet" type-id="XxHash" />
    </union>
    <struct name="Uncompressed" doc="The compression used in the Bloom filter." />
    <union name="BloomFilterCompression">
      <field name="UNCOMPRESSED" field-id="1" required="optional" type="id" type-module="parquet" type-id="Uncompressed" />
    </union>
    <struct name="BloomFilterHeader" doc="Bloom filter header is stored at beginning of Bloom filter data of each column
and followed by its bitset.">
      <field name="numBytes" field-id="1" doc="The size of bitset in bytes *" required="required" type="i32" />
      <field name="algorithm" field-id="2" doc="The algorithm for setting bits. *" required="required" type="id" type-module="parquet" type-id="BloomFilterAlgorithm" />
      <field name="hash" field-id="3" doc="The hash function used for Bloom filter. *" required="required" type="id" type-module="parquet" type-id="BloomFilterHash" />
      <field name="compression" field-id="4" doc="The compression used in the Bloom filter *" required="required" type="id" type-module="parquet" type-id="BloomFilterCompression" />
    </struct>
    <struct name="PageHeader">
      <field name="type" field-id="1" doc="the type of the page: indicates which of the *_header fields is set *" required="required" type="id" type-module="parquet" type-id="PageType" />
      <field name="uncompressed_page_size" field-id="2" doc="Uncompressed page size in bytes (not including this header) *" required="required" type="i32" />
      <field name="compressed_page_size" field-id="3" doc="Compressed (and potentially encrypted) page size in bytes, not including this header *" required="required" type="i32" />
      <field name="crc" field-id="4" doc="The 32-bit CRC checksum for the page, to be be calculated as follows:

- The standard CRC32 algorithm is used (with polynomial 0x04C11DB7,
  the same as in e.g. GZip).
- All page types can have a CRC (v1 and v2 data pages, dictionary pages,
  etc.).
- The CRC is computed on the serialization binary representation of the page
  (as written to disk), excluding the page header. For example, for v1
  data pages, the CRC is computed on the concatenation of repetition levels,
  definition levels and column values (optionally compressed, optionally
  encrypted).
- The CRC computation therefore takes place after any compression
  and encryption steps, if any.

If enabled, this allows for disabling checksumming in HDFS if only a few
pages need to be read." required="optional" type="i32" />
      <field name="data_page_header" field-id="5" required="optional" type="id" type-module="parquet" type-id="DataPageHeader" />
      <field name="index_page_header" field-id="6" required="optional" type="id" type-module="parquet" type-id="IndexPageHeader" />
      <field name="dictionary_page_header" field-id="7" required="optional" type="id" type-module="parquet" type-id="DictionaryPageHeader" />
      <field name="data_page_header_v2" field-id="8" required="optional" type="id" type-module="parquet" type-id="DataPageHeaderV2" />
    </struct>
    <struct name="KeyValue" doc="Wrapper struct to store key values">
      <field name="key" field-id="1" required="required" type="string" />
      <field name="value" field-id="2" required="optional" type="string" />
    </struct>
    <struct name="SortingColumn" doc="Sort order within a RowGroup of a leaf column">
      <field name="column_idx" field-id="1" doc="The ordinal position of the column (in this row group) *" required="required" type="i32" />
      <field name="descending" field-id="2" doc="If true, indicates this column is sorted in descending order. *" required="required" type="bool" />
      <field name="nulls_first" field-id="3" doc="If true, nulls will come before non-null values, otherwise,
nulls go at the end." required="required" type="bool" />
    </struct>
    <struct name="PageEncodingStats" doc="statistics of a given page type and encoding">
      <field name="page_type" field-id="1" doc="the page type (data/dic/...) *" required="required" type="id" type-module="parquet" type-id="PageType" />
      <field name="encoding" field-id="2" doc="encoding of the page *" required="required" type="id" type-module="parquet" type-id="Encoding" />
      <field name="count" field-id="3" doc="number of pages of this type with this encoding *" required="required" type="i32" />
    </struct>
    <struct name="ColumnMetaData" doc="Description for column metadata">
      <field name="type" field-id="1" doc="Type of this column *" required="required" type="id" type-module="parquet" type-id="Type" />
      <field name="encodings" field-id="2" doc="Set of all encodings used for this column. The purpose is to validate
whether we can decode those pages. *" required="required" type="list">
        <elemType type="id" type-module="parquet" type-id="Encoding" />
      </field>
      <field name="path_in_schema" field-id="3" doc="Path in schema *" required="required" type="list">
        <elemType type="string" />
      </field>
      <field name="codec" field-id="4" doc="Compression codec *" required="required" type="id" type-module="parquet" type-id="CompressionCodec" />
      <field name="num_values" field-id="5" doc="Number of values in this column *" required="required" type="i64" />
      <field name="total_uncompressed_size" field-id="6" doc="total byte size of all uncompressed pages in this column chunk (including the headers) *" required="required" type="i64" />
      <field name="total_compressed_size" field-id="7" doc="total byte size of all compressed, and potentially encrypted, pages
in this column chunk (including the headers) *" required="required" type="i64" />
      <field name="key_value_metadata" field-id="8" doc="Optional key/value metadata *" required="optional" type="list">
        <elemType type="id" type-module="parquet" type-id="KeyValue" />
      </field>
      <field name="data_page_offset" field-id="9" doc="Byte offset from beginning of file to first data page *" required="required" type="i64" />
      <field name="index_page_offset" field-id="10" doc="Byte offset from beginning of file to root index page *" required="optional" type="i64" />
      <field name="dictionary_page_offset" field-id="11" doc="Byte offset from the beginning of file to first (only) dictionary page *" required="optional" type="i64" />
      <field name="statistics" field-id="12" doc="optional statistics for this column chunk" required="optional" type="id" type-module="parquet" type-id="Statistics" />
      <field name="encoding_stats" field-id="13" doc="Set of all encodings used for pages in this column chunk.
This information can be used to determine if all data pages are
dictionary encoded for example *" required="optional" type="list">
        <elemType type="id" type-module="parquet" type-id="PageEncodingStats" />
      </field>
      <field name="bloom_filter_offset" field-id="14" doc="Byte offset from beginning of file to Bloom filter data. *" required="optional" type="i64" />
      <field name="bloom_filter_length" field-id="15" doc="Size of Bloom filter data including the serialized header, in bytes.
Added in 2.10 so readers may not read this field from old files and
it can be obtained after the BloomFilterHeader has been deserialized.
Writers should write this field so readers can read the bloom filter
in a single I/O." required="optional" type="i32" />
      <field name="size_statistics" field-id="16" doc="Optional statistics to help estimate total memory when converted to in-memory
representations. The histograms contained in these statistics can
also be useful in some cases for more fine-grained nullability/list length
filter pushdown." required="optional" type="id" type-module="parquet" type-id="SizeStatistics" />
    </struct>
    <struct name="EncryptionWithFooterKey" />
    <struct name="EncryptionWithColumnKey">
      <field name="path_in_schema" field-id="1" doc="Column path in schema *" required="required" type="list">
        <elemType type="string" />
      </field>
      <field name="key_metadata" field-id="2" doc="Retrieval metadata of column encryption key *" required="optional" type="binary" />
    </struct>
    <union name="ColumnCryptoMetaData">
      <field name="ENCRYPTION_WITH_FOOTER_KEY" field-id="1" required="optional" type="id" type-module="parquet" type-id="EncryptionWithFooterKey" />
      <field name="ENCRYPTION_WITH_COLUMN_KEY" field-id="2" required="optional" type="id" type-module="parquet" type-id="EncryptionWithColumnKey" />
    </union>
    <struct name="ColumnChunk">
      <field name="file_path" field-id="1" doc="File where column data is stored.  If not set, assumed to be same file as
metadata.  This path is relative to the current file." required="optional" type="string" />
      <field name="file_offset" field-id="2" doc="Deprecated: Byte offset in file_path to the ColumnMetaData

Past use of this field has been inconsistent, with some implementations
using it to point to the ColumnMetaData and some using it to point to
the first page in the column chunk. In many cases, the ColumnMetaData at this
location is wrong. This field is now deprecated and should not be used.
Writers should set this field to 0 if no ColumnMetaData has been written outside
the footer." required="required" type="i64">
        <default>
          <int>0</int>
        </default>
      </field>
      <field name="meta_data" field-id="3" doc="Column metadata for this chunk. Some writers may also replicate this at the
location pointed to by file_path/file_offset.
Note: while marked as optional, this field is in fact required by most major
Parquet implementations. As such, writers MUST populate this field." required="optional" type="id" type-module="parquet" type-id="ColumnMetaData" />
      <field name="offset_index_offset" field-id="4" doc="File offset of ColumnChunk&apos;s OffsetIndex *" required="optional" type="i64" />
      <field name="offset_index_length" field-id="5" doc="Size of ColumnChunk&apos;s OffsetIndex, in bytes *" required="optional" type="i32" />
      <field name="column_index_offset" field-id="6" doc="File offset of ColumnChunk&apos;s ColumnIndex *" required="optional" type="i64" />
      <field name="column_index_length" field-id="7" doc="Size of ColumnChunk&apos;s ColumnIndex, in bytes *" required="optional" type="i32" />
      <field name="crypto_metadata" field-id="8" doc="Crypto metadata of encrypted columns *" required="optional" type="id" type-module="parquet" type-id="ColumnCryptoMetaData" />
      <field name="encrypted_column_metadata" field-id="9" doc="Encrypted column metadata for this chunk *" required="optional" type="binary" />
    </struct>
    <struct name="RowGroup">
      <field name="columns" field-id="1" doc="Metadata for each column chunk in this row group.
This list must have the same order as the SchemaElement list in FileMetaData." required="required" type="list">
        <elemType type="id" type-module="parquet" type-id="ColumnChunk" />
      </field>
      <field name="total_byte_size" field-id="2" doc="Total byte size of all the uncompressed column data in this row group *" required="required" type="i64" />
      <field name="num_rows" field-id="3" doc="Number of rows in this row group *" required="required" type="i64" />
      <field name="sorting_columns" field-id="4" doc="If set, specifies a sort ordering of the rows in this RowGroup.
The sorting columns can be a subset of all the columns." required="optional" type="list">
        <elemType type="id" type-module="parquet" type-id="SortingColumn" />
      </field>
      <field name="file_offset" field-id="5" doc="Byte offset from beginning of file to first page (data or dictionary)
in this row group *" required="optional" type="i64" />
      <field name="total_compressed_size" field-id="6" doc="Total byte size of all compressed (and potentially encrypted) column data
in this row group *" required="optional" type="i64" />
      <field name="ordinal" field-id="7" doc="Row group ordinal in the file *" required="optional" type="i16" />
    </struct>
    <struct name="TypeDefinedOrder" doc="Empty struct to signal the order defined by the physical or logical type" />
    <union name="ColumnOrder" doc="Union to specify the order used for the min_value and max_value fields for a
column. This union takes the role of an enhanced enum that allows rich
elements (which will be needed for a collation-based ordering in the future).

Possible values are:
* TypeDefinedOrder - the column uses the order defined by its logical or
                     physical type (if there is no logical type).

If the reader does not support the value of this union, min and max stats
for this column should be ignored.">
      <field name="TYPE_ORDER" field-id="1" doc="The sort orders for logical types are:
  UTF8 - unsigned byte-wise comparison
  INT8 - signed comparison
  INT16 - signed comparison
  INT32 - signed comparison
  INT64 - signed comparison
  UINT8 - unsigned comparison
  UINT16 - unsigned comparison
  UINT32 - unsigned comparison
  UINT64 - unsigned comparison
  DECIMAL - signed comparison of the represented value
  DATE - signed comparison
  TIME_MILLIS - signed comparison
  TIME_MICROS - signed comparison
  TIMESTAMP_MILLIS - signed comparison
  TIMESTAMP_MICROS - signed comparison
  INTERVAL - undefined
  JSON - unsigned byte-wise comparison
  BSON - unsigned byte-wise comparison
  ENUM - unsigned byte-wise comparison
  LIST - undefined
  MAP - undefined
  VARIANT - undefined

In the absence of logical types, the sort order is determined by the physical type:
  BOOLEAN - false, true
  INT32 - signed comparison
  INT64 - signed comparison
  INT96 (only used for legacy timestamps) - undefined
  FLOAT - signed comparison of the represented value (*)
  DOUBLE - signed comparison of the represented value (*)
  BYTE_ARRAY - unsigned byte-wise comparison
  FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison

(*) Because the sorting order is not specified properly for floating
    point values (relations vs. total ordering) the following
    compatibility rules should be applied when reading statistics:
    - If the min is a NaN, it should be ignored.
    - If the max is a NaN, it should be ignored.
    - If the min is +0, the row group may contain -0 values as well.
    - If the max is -0, the row group may contain +0 values as well.
    - When looking for NaN values, min and max should be ignored.

    When writing statistics the following rules should be followed:
    - NaNs should not be written to min or max statistics fields.
    - If the computed max value is zero (whether negative or positive),
      `+0.0` should be written into the max statistics field.
    - If the computed min value is zero (whether negative or positive),
      `-0.0` should be written into the min statistics field." required="optional" type="id" type-module="parquet" type-id="TypeDefinedOrder" />
    </union>
    <struct name="PageLocation">
      <field name="offset" field-id="1" doc="Offset of the page in the file *" required="required" type="i64" />
      <field name="compressed_page_size" field-id="2" doc="Size of the page, including header. Sum of compressed_page_size and header
length" required="required" type="i32" />
      <field name="first_row_index" field-id="3" doc="Index within the RowGroup of the first row of the page. When an
OffsetIndex is present, pages must begin on row boundaries
(repetition_level = 0)." required="required" type="i64" />
    </struct>
    <struct name="OffsetIndex" doc="Optional offsets for each data page in a ColumnChunk.

Forms part of the page index, along with ColumnIndex.

OffsetIndex may be present even if ColumnIndex is not.">
      <field name="page_locations" field-id="1" doc="PageLocations, ordered by increasing PageLocation.offset. It is required
that page_locations[i].first_row_index &lt; page_locations[i+1].first_row_index." required="required" type="list">
        <elemType type="id" type-module="parquet" type-id="PageLocation" />
      </field>
      <field name="unencoded_byte_array_data_bytes" field-id="2" doc="Unencoded/uncompressed size for BYTE_ARRAY types.

See documention for unencoded_byte_array_data_bytes in SizeStatistics for
more details on this field." required="optional" type="list">
        <elemType type="i64" />
      </field>
    </struct>
    <struct name="ColumnIndex" doc="Optional statistics for each data page in a ColumnChunk.

Forms part the page index, along with OffsetIndex.

If this structure is present, OffsetIndex must also be present.

For each field in this structure, &lt;field&gt;[i] refers to the page at
OffsetIndex.page_locations[i]">
      <field name="null_pages" field-id="1" doc="A list of Boolean values to determine the validity of the corresponding
min and max values. If true, a page contains only null values, and writers
have to set the corresponding entries in min_values and max_values to
byte[0], so that all lists have the same length. If false, the
corresponding entries in min_values and max_values must be valid." required="required" type="list">
        <elemType type="bool" />
      </field>
      <field name="min_values" field-id="2" doc="Two lists containing lower and upper bounds for the values of each page
determined by the ColumnOrder of the column. These may be the actual
minimum and maximum values found on a page, but can also be (more compact)
values that do not exist on a page. For example, instead of storing &quot;&quot;Blart
Versenwald III&quot;, a writer may set min_values[i]=&quot;B&quot;, max_values[i]=&quot;C&quot;.
Such more compact values must still be valid values within the column&apos;s
logical type. Readers must make sure that list entries are populated before
using them by inspecting null_pages." required="required" type="list">
        <elemType type="binary" />
      </field>
      <field name="max_values" field-id="3" required="required" type="list">
        <elemType type="binary" />
      </field>
      <field name="boundary_order" field-id="4" doc="Stores whether both min_values and max_values are ordered and if so, in
which direction. This allows readers to perform binary searches in both
lists. Readers cannot assume that max_values[i] &lt;= min_values[i+1], even
if the lists are ordered." required="required" type="id" type-module="parquet" type-id="BoundaryOrder" />
      <field name="null_counts" field-id="5" doc="A list containing the number of null values for each page

Writers SHOULD always write this field even if no null values
are present or the column is not nullable.
Readers MUST distinguish between null_counts not being present
and null_count being 0.
If null_counts are not present, readers MUST NOT assume all
null counts are 0." required="optional" type="list">
        <elemType type="i64" />
      </field>
      <field name="repetition_level_histograms" field-id="6" doc="Contains repetition level histograms for each page
concatenated together.  The repetition_level_histogram field on
SizeStatistics contains more details.

When present the length should always be (number of pages *
(max_repetition_level + 1)) elements.

Element 0 is the first element of the histogram for the first page.
Element (max_repetition_level + 1) is the first element of the histogram
for the second page." required="optional" type="list">
        <elemType type="i64" />
      </field>
      <field name="definition_level_histograms" field-id="7" doc="Same as repetition_level_histograms except for definitions levels." required="optional" type="list">
        <elemType type="i64" />
      </field>
    </struct>
    <struct name="AesGcmV1">
      <field name="aad_prefix" field-id="1" doc="AAD prefix *" required="optional" type="binary" />
      <field name="aad_file_unique" field-id="2" doc="Unique file identifier part of AAD suffix *" required="optional" type="binary" />
      <field name="supply_aad_prefix" field-id="3" doc="In files encrypted with AAD prefix without storing it,
readers must supply the prefix *" required="optional" type="bool" />
    </struct>
    <struct name="AesGcmCtrV1">
      <field name="aad_prefix" field-id="1" doc="AAD prefix *" required="optional" type="binary" />
      <field name="aad_file_unique" field-id="2" doc="Unique file identifier part of AAD suffix *" required="optional" type="binary" />
      <field name="supply_aad_prefix" field-id="3" doc="In files encrypted with AAD prefix without storing it,
readers must supply the prefix *" required="optional" type="bool" />
    </struct>
    <union name="EncryptionAlgorithm">
      <field name="AES_GCM_V1" field-id="1" required="optional" type="id" type-module="parquet" type-id="AesGcmV1" />
      <field name="AES_GCM_CTR_V1" field-id="2" required="optional" type="id" type-module="parquet" type-id="AesGcmCtrV1" />
    </union>
    <struct name="FileMetaData" doc="Description for file metadata">
      <field name="version" field-id="1" doc="Version of this file *" required="required" type="i32" />
      <field name="schema" field-id="2" doc="Parquet schema for this file.  This schema contains metadata for all the columns.
The schema is represented as a tree with a single root.  The nodes of the tree
are flattened to a list by doing a depth-first traversal.
The column metadata contains the path in the schema for that column which can be
used to map columns to nodes in the schema.
The first element is the root *" required="required" type="list">
        <elemType type="id" type-module="parquet" type-id="SchemaElement" />
      </field>
      <field name="num_rows" field-id="3" doc="Number of rows in this file *" required="required" type="i64" />
      <field name="row_groups" field-id="4" doc="Row groups in this file *" required="required" type="list">
        <elemType type="id" type-module="parquet" type-id="RowGroup" />
      </field>
      <field name="key_value_metadata" field-id="5" doc="Optional key/value metadata *" required="optional" type="list">
        <elemType type="id" type-module="parquet" type-id="KeyValue" />
      </field>
      <field name="created_by" field-id="6" doc="String for application that wrote this file.  This should be in the format
&lt;Application&gt; version &lt;App Version&gt; (build &lt;App Build Hash&gt;).
e.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)" required="optional" type="string" />
      <field name="column_orders" field-id="7" doc="Sort order used for the min_value and max_value fields in the Statistics
objects and the min_values and max_values fields in the ColumnIndex
objects of each column in this file. Sort orders are listed in the order
matching the columns in the schema. The indexes are not necessary the same
though, because only leaf nodes of the schema are represented in the list
of sort orders.

Without column_orders, the meaning of the min_value and max_value fields
in the Statistics object and the ColumnIndex object is undefined. To ensure
well-defined behaviour, if these fields are written to a Parquet file,
column_orders must be written as well.

The obsolete min and max fields in the Statistics object are always sorted
by signed comparison regardless of column_orders." required="optional" type="list">
        <elemType type="id" type-module="parquet" type-id="ColumnOrder" />
      </field>
      <field name="encryption_algorithm" field-id="8" doc="Encryption algorithm. This field is set only in encrypted files
with plaintext footer. Files with encrypted footer store algorithm id
in FileCryptoMetaData structure." required="optional" type="id" type-module="parquet" type-id="EncryptionAlgorithm" />
      <field name="footer_signing_key_metadata" field-id="9" doc="Retrieval metadata of key used for signing the footer.
Used only in encrypted files with plaintext footer." required="optional" type="binary" />
    </struct>
    <struct name="FileCryptoMetaData" doc="Crypto metadata for files with encrypted footer *">
      <field name="encryption_algorithm" field-id="1" doc="Encryption algorithm. This field is only used for files
with encrypted footer. Files with plaintext footer store algorithm id
inside footer (FileMetaData structure)." required="required" type="id" type-module="parquet" type-id="EncryptionAlgorithm" />
      <field name="key_metadata" field-id="2" doc="Retrieval metadata of key used for encryption of footer,
and (possibly) columns *" required="optional" type="binary" />
    </struct>
  </document>
</idl>
