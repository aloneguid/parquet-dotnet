{
  "name": "parquet",
  "doc": "Licensed to the Apache Software Foundation (ASF) under one\nor more contributor license agreements.  See the NOTICE file\ndistributed with this work for additional information\nregarding copyright ownership.  The ASF licenses this file\nto you under the Apache License, Version 2.0 (the\n\"License\"); you may not use this file except in compliance\nwith the License.  You may obtain a copy of the License at\n\n    http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing,\nsoftware distributed under the License is distributed on an\n\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\nKIND, either express or implied.  See the License for the\nspecific language governing permissions and limitations\nunder the License.\n",
  "namespaces": {
    "cpp": "parquet",
    "java": "org.apache.parquet.format",
    "netstd": "Parquet.Thrift"
  },
  "includes": [
  ],
  "enums": [
    {
      "name": "Type",
      "doc": "Types supported by Parquet.  These types are intended to be used in combination\nwith the encodings to control the on disk storage format.\nFor example INT16 is not included as a type since a good encoding of INT32\nwould handle this.\n",
      "members": [
        {
          "name": "BOOLEAN",
          "value": 0
        },
        {
          "name": "INT32",
          "value": 1
        },
        {
          "name": "INT64",
          "value": 2
        },
        {
          "name": "INT96",
          "value": 3
        },
        {
          "name": "FLOAT",
          "value": 4
        },
        {
          "name": "DOUBLE",
          "value": 5
        },
        {
          "name": "BYTE_ARRAY",
          "value": 6
        },
        {
          "name": "FIXED_LEN_BYTE_ARRAY",
          "value": 7
        }
      ]
    },
    {
      "name": "ConvertedType",
      "doc": "DEPRECATED: Common types used by frameworks(e.g. hive, pig) using parquet.\nConvertedType is superseded by LogicalType.  This enum should not be extended.\n\nSee LogicalTypes.md for conversion between ConvertedType and LogicalType.\n",
      "members": [
        {
          "name": "UTF8",
          "value": 0,
          "doc": "a BYTE_ARRAY actually contains UTF8 encoded chars\n"
        },
        {
          "name": "MAP",
          "value": 1,
          "doc": "a map is converted as an optional field containing a repeated key\/value pair\n"
        },
        {
          "name": "MAP_KEY_VALUE",
          "value": 2,
          "doc": "a key\/value pair is converted into a group of two fields\n"
        },
        {
          "name": "LIST",
          "value": 3,
          "doc": "a list is converted into an optional field containing a repeated field for its\nvalues\n"
        },
        {
          "name": "ENUM",
          "value": 4,
          "doc": "an enum is converted into a binary field\n"
        },
        {
          "name": "DECIMAL",
          "value": 5,
          "doc": "A decimal value.\n\nThis may be used to annotate binary or fixed primitive types. The\nunderlying byte array stores the unscaled value encoded as two's\ncomplement using big-endian byte order (the most significant byte is the\nzeroth element). The value of the decimal is the value * 10^{-scale}.\n\nThis must be accompanied by a (maximum) precision and a scale in the\nSchemaElement. The precision specifies the number of digits in the decimal\nand the scale stores the location of the decimal point. For example 1.23\nwould have precision 3 (3 total digits) and scale 2 (the decimal point is\n2 digits over).\n"
        },
        {
          "name": "DATE",
          "value": 6,
          "doc": "A Date\n\nStored as days since Unix epoch, encoded as the INT32 physical type.\n\n"
        },
        {
          "name": "TIME_MILLIS",
          "value": 7,
          "doc": "A time\n\nThe total number of milliseconds since midnight.  The value is stored\nas an INT32 physical type.\n"
        },
        {
          "name": "TIME_MICROS",
          "value": 8,
          "doc": "A time.\n\nThe total number of microseconds since midnight.  The value is stored as\nan INT64 physical type.\n"
        },
        {
          "name": "TIMESTAMP_MILLIS",
          "value": 9,
          "doc": "A date\/time combination\n\nDate and time recorded as milliseconds since the Unix epoch.  Recorded as\na physical type of INT64.\n"
        },
        {
          "name": "TIMESTAMP_MICROS",
          "value": 10,
          "doc": "A date\/time combination\n\nDate and time recorded as microseconds since the Unix epoch.  The value is\nstored as an INT64 physical type.\n"
        },
        {
          "name": "UINT_8",
          "value": 11,
          "doc": "An unsigned integer value.\n\nThe number describes the maximum number of meaningful data bits in\nthe stored value. 8, 16 and 32 bit values are stored using the\nINT32 physical type.  64 bit values are stored using the INT64\nphysical type.\n\n"
        },
        {
          "name": "UINT_16",
          "value": 12
        },
        {
          "name": "UINT_32",
          "value": 13
        },
        {
          "name": "UINT_64",
          "value": 14
        },
        {
          "name": "INT_8",
          "value": 15,
          "doc": "A signed integer value.\n\nThe number describes the maximum number of meaningful data bits in\nthe stored value. 8, 16 and 32 bit values are stored using the\nINT32 physical type.  64 bit values are stored using the INT64\nphysical type.\n\n"
        },
        {
          "name": "INT_16",
          "value": 16
        },
        {
          "name": "INT_32",
          "value": 17
        },
        {
          "name": "INT_64",
          "value": 18
        },
        {
          "name": "JSON",
          "value": 19,
          "doc": "An embedded JSON document\n\nA JSON document embedded within a single UTF8 column.\n"
        },
        {
          "name": "BSON",
          "value": 20,
          "doc": "An embedded BSON document\n\nA BSON document embedded within a single BINARY column.\n"
        },
        {
          "name": "INTERVAL",
          "value": 21,
          "doc": "An interval of time\n\nThis type annotates data stored as a FIXED_LEN_BYTE_ARRAY of length 12\nThis data is composed of three separate little endian unsigned\nintegers.  Each stores a component of a duration of time.  The first\ninteger identifies the number of months associated with the duration,\nthe second identifies the number of days associated with the duration\nand the third identifies the number of milliseconds associated with\nthe provided duration.  This duration of time is independent of any\nparticular timezone or date.\n"
        }
      ]
    },
    {
      "name": "FieldRepetitionType",
      "doc": "Representation of Schemas\n",
      "members": [
        {
          "name": "REQUIRED",
          "value": 0,
          "doc": "This field is required (can not be null) and each record has exactly 1 value.\n"
        },
        {
          "name": "OPTIONAL",
          "value": 1,
          "doc": "The field is optional (can be null) and each record has 0 or 1 values.\n"
        },
        {
          "name": "REPEATED",
          "value": 2,
          "doc": "The field is repeated and can contain 0 or more values\n"
        }
      ]
    },
    {
      "name": "Encoding",
      "doc": "Encodings supported by Parquet.  Not all encodings are valid for all types.  These\nenums are also used to specify the encoding of definition and repetition levels.\nSee the accompanying doc for the details of the more complicated encodings.\n",
      "members": [
        {
          "name": "PLAIN",
          "value": 0,
          "doc": "Default encoding.\nBOOLEAN - 1 bit per value. 0 is false; 1 is true.\nINT32 - 4 bytes per value.  Stored as little-endian.\nINT64 - 8 bytes per value.  Stored as little-endian.\nFLOAT - 4 bytes per value.  IEEE. Stored as little-endian.\nDOUBLE - 8 bytes per value.  IEEE. Stored as little-endian.\nBYTE_ARRAY - 4 byte length stored as little endian, followed by bytes.\nFIXED_LEN_BYTE_ARRAY - Just the bytes.\n"
        },
        {
          "name": "PLAIN_DICTIONARY",
          "value": 2,
          "doc": "Deprecated: Dictionary encoding. The values in the dictionary are encoded in the\nplain type.\nin a data page use RLE_DICTIONARY instead.\nin a Dictionary page use PLAIN instead\n"
        },
        {
          "name": "RLE",
          "value": 3,
          "doc": "Group packed run length encoding. Usable for definition\/repetition levels\nencoding and Booleans (on one bit: 0 is false; 1 is true.)\n"
        },
        {
          "name": "BIT_PACKED",
          "value": 4,
          "doc": "Bit packed encoding.  This can only be used if the data has a known max\nwidth.  Usable for definition\/repetition levels encoding.\n"
        },
        {
          "name": "DELTA_BINARY_PACKED",
          "value": 5,
          "doc": "Delta encoding for integers. This can be used for int columns and works best\non sorted data\n"
        },
        {
          "name": "DELTA_LENGTH_BYTE_ARRAY",
          "value": 6,
          "doc": "Encoding for byte arrays to separate the length values and the data. The lengths\nare encoded using DELTA_BINARY_PACKED\n"
        },
        {
          "name": "DELTA_BYTE_ARRAY",
          "value": 7,
          "doc": "Incremental-encoded byte array. Prefix lengths are encoded using DELTA_BINARY_PACKED.\nSuffixes are stored as delta length byte arrays.\n"
        },
        {
          "name": "RLE_DICTIONARY",
          "value": 8,
          "doc": "Dictionary encoding: the ids are encoded using the RLE encoding\n"
        },
        {
          "name": "BYTE_STREAM_SPLIT",
          "value": 9,
          "doc": "Encoding for floating-point data.\nK byte-streams are created where K is the size in bytes of the data type.\nThe individual bytes of an FP value are scattered to the corresponding stream and\nthe streams are concatenated.\nThis itself does not reduce the size of the data but can lead to better compression\nafterwards.\n"
        }
      ]
    },
    {
      "name": "CompressionCodec",
      "doc": "Supported compression algorithms.\n\nCodecs added in format version X.Y can be read by readers based on X.Y and later.\nCodec support may vary between readers based on the format version and\nlibraries available at runtime.\n\nSee Compression.md for a detailed specification of these algorithms.\n",
      "members": [
        {
          "name": "UNCOMPRESSED",
          "value": 0
        },
        {
          "name": "SNAPPY",
          "value": 1
        },
        {
          "name": "GZIP",
          "value": 2
        },
        {
          "name": "LZO",
          "value": 3
        },
        {
          "name": "BROTLI",
          "value": 4
        },
        {
          "name": "LZ4",
          "value": 5
        },
        {
          "name": "ZSTD",
          "value": 6
        },
        {
          "name": "LZ4_RAW",
          "value": 7
        }
      ]
    },
    {
      "name": "PageType",
      "members": [
        {
          "name": "DATA_PAGE",
          "value": 0
        },
        {
          "name": "INDEX_PAGE",
          "value": 1
        },
        {
          "name": "DICTIONARY_PAGE",
          "value": 2
        },
        {
          "name": "DATA_PAGE_V2",
          "value": 3
        }
      ]
    },
    {
      "name": "BoundaryOrder",
      "doc": "Enum to annotate whether lists of min\/max elements inside ColumnIndex\nare ordered and if so, in which direction.\n",
      "members": [
        {
          "name": "UNORDERED",
          "value": 0
        },
        {
          "name": "ASCENDING",
          "value": 1
        },
        {
          "name": "DESCENDING",
          "value": 2
        }
      ]
    }
  ],
  "typedefs": [
  ],
  "structs": [
    {
      "name": "Statistics",
      "doc": "Statistics per row group and per page\nAll fields are optional.\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "max",
          "typeId": "binary",
          "doc": "DEPRECATED: min and max value of the column. Use min_value and max_value.\n\nValues are encoded using PLAIN encoding, except that variable-length byte\narrays do not include a length prefix.\n\nThese fields encode min and max values determined by signed comparison\nonly. New files should use the correct order for a column's logical type\nand store the values in the min_value and max_value fields.\n\nTo support older readers, these may be set when the column order is\nsigned.\n",
          "required": "optional"
        },
        {
          "key": 2,
          "name": "min",
          "typeId": "binary",
          "required": "optional"
        },
        {
          "key": 3,
          "name": "null_count",
          "typeId": "i64",
          "doc": "count of null value in the column\n",
          "required": "optional"
        },
        {
          "key": 4,
          "name": "distinct_count",
          "typeId": "i64",
          "doc": "count of distinct values occurring\n",
          "required": "optional"
        },
        {
          "key": 5,
          "name": "max_value",
          "typeId": "binary",
          "doc": "Min and max values for the column, determined by its ColumnOrder.\n\nValues are encoded using PLAIN encoding, except that variable-length byte\narrays do not include a length prefix.\n",
          "required": "optional"
        },
        {
          "key": 6,
          "name": "min_value",
          "typeId": "binary",
          "required": "optional"
        }
      ]
    },
    {
      "name": "StringType",
      "doc": "Empty structs to use as logical type annotations\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "UUIDType",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "MapType",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "ListType",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "EnumType",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "DateType",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "NullType",
      "doc": "Logical type to annotate a column that is always null.\n\nSometimes when discovering the schema of existing data, values are always\nnull and the physical type can't be determined. This annotation signals\nthe case where the physical type was guessed from all null values.\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "DecimalType",
      "doc": "Decimal logical type annotation\n\nTo maintain forward-compatibility in v1, implementations using this logical\ntype must also set scale and precision on the annotated SchemaElement.\n\nAllowed for physical types: INT32, INT64, FIXED, and BINARY\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "scale",
          "typeId": "i32",
          "required": "required"
        },
        {
          "key": 2,
          "name": "precision",
          "typeId": "i32",
          "required": "required"
        }
      ]
    },
    {
      "name": "MilliSeconds",
      "doc": "Time units for logical types\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "MicroSeconds",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "NanoSeconds",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "TimeUnit",
      "isException": false,
      "isUnion": true,
      "fields": [
        {
          "key": 1,
          "name": "MILLIS",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "MilliSeconds"
          },
          "required": "optional"
        },
        {
          "key": 2,
          "name": "MICROS",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "MicroSeconds"
          },
          "required": "optional"
        },
        {
          "key": 3,
          "name": "NANOS",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "NanoSeconds"
          },
          "required": "optional"
        }
      ]
    },
    {
      "name": "TimestampType",
      "doc": "Timestamp logical type annotation\n\nAllowed for physical types: INT64\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "isAdjustedToUTC",
          "typeId": "bool",
          "required": "required"
        },
        {
          "key": 2,
          "name": "unit",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "TimeUnit"
          },
          "required": "required"
        }
      ]
    },
    {
      "name": "TimeType",
      "doc": "Time logical type annotation\n\nAllowed for physical types: INT32 (millis), INT64 (micros, nanos)\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "isAdjustedToUTC",
          "typeId": "bool",
          "required": "required"
        },
        {
          "key": 2,
          "name": "unit",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "TimeUnit"
          },
          "required": "required"
        }
      ]
    },
    {
      "name": "IntType",
      "doc": "Integer logical type annotation\n\nbitWidth must be 8, 16, 32, or 64.\n\nAllowed for physical types: INT32, INT64\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "bitWidth",
          "typeId": "i8",
          "required": "required"
        },
        {
          "key": 2,
          "name": "isSigned",
          "typeId": "bool",
          "required": "required"
        }
      ]
    },
    {
      "name": "JsonType",
      "doc": "Embedded JSON logical type annotation\n\nAllowed for physical types: BINARY\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "BsonType",
      "doc": "Embedded BSON logical type annotation\n\nAllowed for physical types: BINARY\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "LogicalType",
      "doc": "LogicalType annotations to replace ConvertedType.\n\nTo maintain compatibility, implementations using LogicalType for a\nSchemaElement must also set the corresponding ConvertedType (if any)\nfrom the following table.\n",
      "isException": false,
      "isUnion": true,
      "fields": [
        {
          "key": 1,
          "name": "STRING",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "StringType"
          },
          "required": "optional"
        },
        {
          "key": 2,
          "name": "MAP",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "MapType"
          },
          "required": "optional"
        },
        {
          "key": 3,
          "name": "LIST",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "ListType"
          },
          "required": "optional"
        },
        {
          "key": 4,
          "name": "ENUM",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "EnumType"
          },
          "required": "optional"
        },
        {
          "key": 5,
          "name": "DECIMAL",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "DecimalType"
          },
          "required": "optional"
        },
        {
          "key": 6,
          "name": "DATE",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "DateType"
          },
          "required": "optional"
        },
        {
          "key": 7,
          "name": "TIME",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "TimeType"
          },
          "required": "optional"
        },
        {
          "key": 8,
          "name": "TIMESTAMP",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "TimestampType"
          },
          "required": "optional"
        },
        {
          "key": 10,
          "name": "INTEGER",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "IntType"
          },
          "required": "optional"
        },
        {
          "key": 11,
          "name": "UNKNOWN",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "NullType"
          },
          "required": "optional"
        },
        {
          "key": 12,
          "name": "JSON",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "JsonType"
          },
          "required": "optional"
        },
        {
          "key": 13,
          "name": "BSON",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "BsonType"
          },
          "required": "optional"
        },
        {
          "key": 14,
          "name": "UUID",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "UUIDType"
          },
          "required": "optional"
        }
      ]
    },
    {
      "name": "SchemaElement",
      "doc": "Represents a element inside a schema definition.\n - if it is a group (inner node) then type is undefined and num_children is defined\n - if it is a primitive type (leaf) then type is defined and num_children is undefined\nthe nodes are listed in depth first traversal order.\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "type",
          "typeId": "i32",
          "doc": "Data type for this field. Not set if the current element is a non-leaf node\n",
          "required": "optional"
        },
        {
          "key": 2,
          "name": "type_length",
          "typeId": "i32",
          "doc": "If type is FIXED_LEN_BYTE_ARRAY, this is the byte length of the vales.\nOtherwise, if specified, this is the maximum bit length to store any of the values.\n(e.g. a low cardinality INT col could have this set to 3).  Note that this is\nin the schema, and therefore fixed for the entire file.\n",
          "required": "optional"
        },
        {
          "key": 3,
          "name": "repetition_type",
          "typeId": "i32",
          "doc": "repetition of the field. The root of the schema does not have a repetition_type.\nAll other nodes must have one\n",
          "required": "optional"
        },
        {
          "key": 4,
          "name": "name",
          "typeId": "string",
          "doc": "Name of the field in the schema\n",
          "required": "required"
        },
        {
          "key": 5,
          "name": "num_children",
          "typeId": "i32",
          "doc": "Nested fields.  Since thrift does not support nested fields,\nthe nesting is flattened to a single list by a depth-first traversal.\nThe children count is used to construct the nested relationship.\nThis field is not set when the element is a primitive type\n",
          "required": "optional"
        },
        {
          "key": 6,
          "name": "converted_type",
          "typeId": "i32",
          "doc": "DEPRECATED: When the schema is the result of a conversion from another model.\nUsed to record the original type to help with cross conversion.\n\nThis is superseded by logicalType.\n",
          "required": "optional"
        },
        {
          "key": 7,
          "name": "scale",
          "typeId": "i32",
          "doc": "DEPRECATED: Used when this column contains decimal data.\nSee the DECIMAL converted type for more details.\n\nThis is superseded by using the DecimalType annotation in logicalType.\n",
          "required": "optional"
        },
        {
          "key": 8,
          "name": "precision",
          "typeId": "i32",
          "required": "optional"
        },
        {
          "key": 9,
          "name": "field_id",
          "typeId": "i32",
          "doc": "When the original schema supports field ids, this will save the\noriginal field id in the parquet schema\n",
          "required": "optional"
        },
        {
          "key": 10,
          "name": "logicalType",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "LogicalType"
          },
          "doc": "The logical type of this SchemaElement\n\nLogicalType replaces ConvertedType, but ConvertedType is still required\nfor some logical types to ensure forward-compatibility in format v1.\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "DataPageHeader",
      "doc": "Data page header\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "num_values",
          "typeId": "i32",
          "doc": "Number of values, including NULLs, in this data page. *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "encoding",
          "typeId": "i32",
          "doc": "Encoding used for this data page *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "definition_level_encoding",
          "typeId": "i32",
          "doc": "Encoding used for definition levels *\n",
          "required": "required"
        },
        {
          "key": 4,
          "name": "repetition_level_encoding",
          "typeId": "i32",
          "doc": "Encoding used for repetition levels *\n",
          "required": "required"
        },
        {
          "key": 5,
          "name": "statistics",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "Statistics"
          },
          "doc": "Optional statistics for the data in this page*\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "IndexPageHeader",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "DictionaryPageHeader",
      "doc": "The dictionary page must be placed at the first position of the column chunk\nif it is partly or completely dictionary encoded. At most one dictionary page\ncan be placed in a column chunk.\n\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "num_values",
          "typeId": "i32",
          "doc": "Number of values in the dictionary *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "encoding",
          "typeId": "i32",
          "doc": "Encoding using this dictionary page *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "is_sorted",
          "typeId": "bool",
          "doc": "If true, the entries in the dictionary are sorted in ascending order *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "DataPageHeaderV2",
      "doc": "New page format allowing reading levels without decompressing the data\nRepetition and definition levels are uncompressed\nThe remaining section containing the data is compressed if is_compressed is true\n\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "num_values",
          "typeId": "i32",
          "doc": "Number of values, including NULLs, in this data page. *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "num_nulls",
          "typeId": "i32",
          "doc": "Number of NULL values, in this data page.\nNumber of non-null = num_values - num_nulls which is also the number of values in the data section *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "num_rows",
          "typeId": "i32",
          "doc": "Number of rows in this data page. which means pages change on record boundaries (r = 0) *\n",
          "required": "required"
        },
        {
          "key": 4,
          "name": "encoding",
          "typeId": "i32",
          "doc": "Encoding used for data in this page *\n",
          "required": "required"
        },
        {
          "key": 5,
          "name": "definition_levels_byte_length",
          "typeId": "i32",
          "doc": "length of the definition levels\n",
          "required": "required"
        },
        {
          "key": 6,
          "name": "repetition_levels_byte_length",
          "typeId": "i32",
          "doc": "length of the repetition levels\n",
          "required": "required"
        },
        {
          "key": 7,
          "name": "is_compressed",
          "typeId": "bool",
          "doc": "whether the values are compressed.\nWhich means the section of the page between\ndefinition_levels_byte_length + repetition_levels_byte_length + 1 and compressed_page_size (included)\nis compressed with the compression_codec.\nIf missing it is considered compressed\n",
          "required": "optional",
          "default": 1
        },
        {
          "key": 8,
          "name": "statistics",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "Statistics"
          },
          "doc": "optional statistics for the data in this page *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "SplitBlockAlgorithm",
      "doc": "Block-based algorithm type annotation. *\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "BloomFilterAlgorithm",
      "doc": "The algorithm used in Bloom filter. *\n",
      "isException": false,
      "isUnion": true,
      "fields": [
        {
          "key": 1,
          "name": "BLOCK",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "SplitBlockAlgorithm"
          },
          "doc": "Block-based Bloom filter. *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "XxHash",
      "doc": "Hash strategy type annotation. xxHash is an extremely fast non-cryptographic hash\nalgorithm. It uses 64 bits version of xxHash.\n\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "BloomFilterHash",
      "doc": "The hash function used in Bloom filter. This function takes the hash of a column value\nusing plain encoding.\n\n",
      "isException": false,
      "isUnion": true,
      "fields": [
        {
          "key": 1,
          "name": "XXHASH",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "XxHash"
          },
          "doc": "xxHash Strategy. *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "Uncompressed",
      "doc": "The compression used in the Bloom filter.\n\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "BloomFilterCompression",
      "isException": false,
      "isUnion": true,
      "fields": [
        {
          "key": 1,
          "name": "UNCOMPRESSED",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "Uncompressed"
          },
          "required": "optional"
        }
      ]
    },
    {
      "name": "BloomFilterHeader",
      "doc": "Bloom filter header is stored at beginning of Bloom filter data of each column\nand followed by its bitset.\n\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "numBytes",
          "typeId": "i32",
          "doc": "The size of bitset in bytes *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "algorithm",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "BloomFilterAlgorithm"
          },
          "doc": "The algorithm for setting bits. *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "hash",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "BloomFilterHash"
          },
          "doc": "The hash function used for Bloom filter. *\n",
          "required": "required"
        },
        {
          "key": 4,
          "name": "compression",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "BloomFilterCompression"
          },
          "doc": "The compression used in the Bloom filter *\n",
          "required": "required"
        }
      ]
    },
    {
      "name": "PageHeader",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "type",
          "typeId": "i32",
          "doc": "the type of the page: indicates which of the *_header fields is set *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "uncompressed_page_size",
          "typeId": "i32",
          "doc": "Uncompressed page size in bytes (not including this header) *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "compressed_page_size",
          "typeId": "i32",
          "doc": "Compressed (and potentially encrypted) page size in bytes, not including this header *\n",
          "required": "required"
        },
        {
          "key": 4,
          "name": "crc",
          "typeId": "i32",
          "doc": "The 32bit CRC for the page, to be be calculated as follows:\n- Using the standard CRC32 algorithm\n- On the data only, i.e. this header should not be included. 'Data'\n  hereby refers to the concatenation of the repetition levels, the\n  definition levels and the column value, in this exact order.\n- On the encoded versions of the repetition levels, definition levels and\n  column values\n- On the compressed versions of the repetition levels, definition levels\n  and column values where possible;\n  - For v1 data pages, the repetition levels, definition levels and column\n    values are always compressed together. If a compression scheme is\n    specified, the CRC shall be calculated on the compressed version of\n    this concatenation. If no compression scheme is specified, the CRC\n    shall be calculated on the uncompressed version of this concatenation.\n  - For v2 data pages, the repetition levels and definition levels are\n    handled separately from the data and are never compressed (only\n    encoded). If a compression scheme is specified, the CRC shall be\n    calculated on the concatenation of the uncompressed repetition levels,\n    uncompressed definition levels and the compressed column values.\n    If no compression scheme is specified, the CRC shall be calculated on\n    the uncompressed concatenation.\n- In encrypted columns, CRC is calculated after page encryption; the\n  encryption itself is performed after page compression (if compressed)\nIf enabled, this allows for disabling checksumming in HDFS if only a few\npages need to be read.\n\n",
          "required": "optional"
        },
        {
          "key": 5,
          "name": "data_page_header",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "DataPageHeader"
          },
          "required": "optional"
        },
        {
          "key": 6,
          "name": "index_page_header",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "IndexPageHeader"
          },
          "required": "optional"
        },
        {
          "key": 7,
          "name": "dictionary_page_header",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "DictionaryPageHeader"
          },
          "required": "optional"
        },
        {
          "key": 8,
          "name": "data_page_header_v2",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "DataPageHeaderV2"
          },
          "required": "optional"
        }
      ]
    },
    {
      "name": "KeyValue",
      "doc": "Wrapper struct to store key values\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "key",
          "typeId": "string",
          "required": "required"
        },
        {
          "key": 2,
          "name": "value",
          "typeId": "string",
          "required": "optional"
        }
      ]
    },
    {
      "name": "SortingColumn",
      "doc": "Wrapper struct to specify sort order\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "column_idx",
          "typeId": "i32",
          "doc": "The column index (in this row group) *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "descending",
          "typeId": "bool",
          "doc": "If true, indicates this column is sorted in descending order. *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "nulls_first",
          "typeId": "bool",
          "doc": "If true, nulls will come before non-null values, otherwise,\nnulls go at the end.\n",
          "required": "required"
        }
      ]
    },
    {
      "name": "PageEncodingStats",
      "doc": "statistics of a given page type and encoding\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "page_type",
          "typeId": "i32",
          "doc": "the page type (data\/dic\/...) *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "encoding",
          "typeId": "i32",
          "doc": "encoding of the page *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "count",
          "typeId": "i32",
          "doc": "number of pages of this type with this encoding *\n",
          "required": "required"
        }
      ]
    },
    {
      "name": "ColumnMetaData",
      "doc": "Description for column metadata\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "type",
          "typeId": "i32",
          "doc": "Type of this column *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "encodings",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "i32"
          },
          "doc": "Set of all encodings used for this column. The purpose is to validate\nwhether we can decode those pages. *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "path_in_schema",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "string"
          },
          "doc": "Path in schema *\n",
          "required": "required"
        },
        {
          "key": 4,
          "name": "codec",
          "typeId": "i32",
          "doc": "Compression codec *\n",
          "required": "required"
        },
        {
          "key": 5,
          "name": "num_values",
          "typeId": "i64",
          "doc": "Number of values in this column *\n",
          "required": "required"
        },
        {
          "key": 6,
          "name": "total_uncompressed_size",
          "typeId": "i64",
          "doc": "total byte size of all uncompressed pages in this column chunk (including the headers) *\n",
          "required": "required"
        },
        {
          "key": 7,
          "name": "total_compressed_size",
          "typeId": "i64",
          "doc": "total byte size of all compressed, and potentially encrypted, pages\nin this column chunk (including the headers) *\n",
          "required": "required"
        },
        {
          "key": 8,
          "name": "key_value_metadata",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "struct",
            "elemType": {
              "typeId": "struct",
              "class": "KeyValue"
            }
          },
          "doc": "Optional key\/value metadata *\n",
          "required": "optional"
        },
        {
          "key": 9,
          "name": "data_page_offset",
          "typeId": "i64",
          "doc": "Byte offset from beginning of file to first data page *\n",
          "required": "required"
        },
        {
          "key": 10,
          "name": "index_page_offset",
          "typeId": "i64",
          "doc": "Byte offset from beginning of file to root index page *\n",
          "required": "optional"
        },
        {
          "key": 11,
          "name": "dictionary_page_offset",
          "typeId": "i64",
          "doc": "Byte offset from the beginning of file to first (only) dictionary page *\n",
          "required": "optional"
        },
        {
          "key": 12,
          "name": "statistics",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "Statistics"
          },
          "doc": "optional statistics for this column chunk\n",
          "required": "optional"
        },
        {
          "key": 13,
          "name": "encoding_stats",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "struct",
            "elemType": {
              "typeId": "struct",
              "class": "PageEncodingStats"
            }
          },
          "doc": "Set of all encodings used for pages in this column chunk.\nThis information can be used to determine if all data pages are\ndictionary encoded for example *\n",
          "required": "optional"
        },
        {
          "key": 14,
          "name": "bloom_filter_offset",
          "typeId": "i64",
          "doc": "Byte offset from beginning of file to Bloom filter data. *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "EncryptionWithFooterKey",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "EncryptionWithColumnKey",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "path_in_schema",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "string"
          },
          "doc": "Column path in schema *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "key_metadata",
          "typeId": "binary",
          "doc": "Retrieval metadata of column encryption key *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "ColumnCryptoMetaData",
      "isException": false,
      "isUnion": true,
      "fields": [
        {
          "key": 1,
          "name": "ENCRYPTION_WITH_FOOTER_KEY",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "EncryptionWithFooterKey"
          },
          "required": "optional"
        },
        {
          "key": 2,
          "name": "ENCRYPTION_WITH_COLUMN_KEY",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "EncryptionWithColumnKey"
          },
          "required": "optional"
        }
      ]
    },
    {
      "name": "ColumnChunk",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "file_path",
          "typeId": "string",
          "doc": "File where column data is stored.  If not set, assumed to be same file as\nmetadata.  This path is relative to the current file.\n\n",
          "required": "optional"
        },
        {
          "key": 2,
          "name": "file_offset",
          "typeId": "i64",
          "doc": "Byte offset in file_path to the ColumnMetaData *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "meta_data",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "ColumnMetaData"
          },
          "doc": "Column metadata for this chunk. This is the same content as what is at\nfile_path\/file_offset.  Having it here has it replicated in the file\nmetadata.\n\n",
          "required": "optional"
        },
        {
          "key": 4,
          "name": "offset_index_offset",
          "typeId": "i64",
          "doc": "File offset of ColumnChunk's OffsetIndex *\n",
          "required": "optional"
        },
        {
          "key": 5,
          "name": "offset_index_length",
          "typeId": "i32",
          "doc": "Size of ColumnChunk's OffsetIndex, in bytes *\n",
          "required": "optional"
        },
        {
          "key": 6,
          "name": "column_index_offset",
          "typeId": "i64",
          "doc": "File offset of ColumnChunk's ColumnIndex *\n",
          "required": "optional"
        },
        {
          "key": 7,
          "name": "column_index_length",
          "typeId": "i32",
          "doc": "Size of ColumnChunk's ColumnIndex, in bytes *\n",
          "required": "optional"
        },
        {
          "key": 8,
          "name": "crypto_metadata",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "ColumnCryptoMetaData"
          },
          "doc": "Crypto metadata of encrypted columns *\n",
          "required": "optional"
        },
        {
          "key": 9,
          "name": "encrypted_column_metadata",
          "typeId": "binary",
          "doc": "Encrypted column metadata for this chunk *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "RowGroup",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "columns",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "struct",
            "elemType": {
              "typeId": "struct",
              "class": "ColumnChunk"
            }
          },
          "doc": "Metadata for each column chunk in this row group.\nThis list must have the same order as the SchemaElement list in FileMetaData.\n\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "total_byte_size",
          "typeId": "i64",
          "doc": "Total byte size of all the uncompressed column data in this row group *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "num_rows",
          "typeId": "i64",
          "doc": "Number of rows in this row group *\n",
          "required": "required"
        },
        {
          "key": 4,
          "name": "sorting_columns",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "struct",
            "elemType": {
              "typeId": "struct",
              "class": "SortingColumn"
            }
          },
          "doc": "If set, specifies a sort ordering of the rows in this RowGroup.\nThe sorting columns can be a subset of all the columns.\n",
          "required": "optional"
        },
        {
          "key": 5,
          "name": "file_offset",
          "typeId": "i64",
          "doc": "Byte offset from beginning of file to first page (data or dictionary)\nin this row group *\n",
          "required": "optional"
        },
        {
          "key": 6,
          "name": "total_compressed_size",
          "typeId": "i64",
          "doc": "Total byte size of all compressed (and potentially encrypted) column data\nin this row group *\n",
          "required": "optional"
        },
        {
          "key": 7,
          "name": "ordinal",
          "typeId": "i16",
          "doc": "Row group ordinal in the file *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "TypeDefinedOrder",
      "doc": "Empty struct to signal the order defined by the physical or logical type\n",
      "isException": false,
      "isUnion": false,
      "fields": [
      ]
    },
    {
      "name": "ColumnOrder",
      "doc": "Union to specify the order used for the min_value and max_value fields for a\ncolumn. This union takes the role of an enhanced enum that allows rich\nelements (which will be needed for a collation-based ordering in the future).\n\nPossible values are:\n* TypeDefinedOrder - the column uses the order defined by its logical or\n                     physical type (if there is no logical type).\n\nIf the reader does not support the value of this union, min and max stats\nfor this column should be ignored.\n",
      "isException": false,
      "isUnion": true,
      "fields": [
        {
          "key": 1,
          "name": "TYPE_ORDER",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "TypeDefinedOrder"
          },
          "doc": "The sort orders for logical types are:\n  UTF8 - unsigned byte-wise comparison\n  INT8 - signed comparison\n  INT16 - signed comparison\n  INT32 - signed comparison\n  INT64 - signed comparison\n  UINT8 - unsigned comparison\n  UINT16 - unsigned comparison\n  UINT32 - unsigned comparison\n  UINT64 - unsigned comparison\n  DECIMAL - signed comparison of the represented value\n  DATE - signed comparison\n  TIME_MILLIS - signed comparison\n  TIME_MICROS - signed comparison\n  TIMESTAMP_MILLIS - signed comparison\n  TIMESTAMP_MICROS - signed comparison\n  INTERVAL - unsigned comparison\n  JSON - unsigned byte-wise comparison\n  BSON - unsigned byte-wise comparison\n  ENUM - unsigned byte-wise comparison\n  LIST - undefined\n  MAP - undefined\n\nIn the absence of logical types, the sort order is determined by the physical type:\n  BOOLEAN - false, true\n  INT32 - signed comparison\n  INT64 - signed comparison\n  INT96 (only used for legacy timestamps) - undefined\n  FLOAT - signed comparison of the represented value (*)\n  DOUBLE - signed comparison of the represented value (*)\n  BYTE_ARRAY - unsigned byte-wise comparison\n  FIXED_LEN_BYTE_ARRAY - unsigned byte-wise comparison\n\n(*) Because the sorting order is not specified properly for floating\n    point values (relations vs. total ordering) the following\n    compatibility rules should be applied when reading statistics:\n    - If the min is a NaN, it should be ignored.\n    - If the max is a NaN, it should be ignored.\n    - If the min is +0, the row group may contain -0 values as well.\n    - If the max is -0, the row group may contain +0 values as well.\n    - When looking for NaN values, min and max should be ignored.\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "PageLocation",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "offset",
          "typeId": "i64",
          "doc": "Offset of the page in the file *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "compressed_page_size",
          "typeId": "i32",
          "doc": "Size of the page, including header. Sum of compressed_page_size and header\nlength\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "first_row_index",
          "typeId": "i64",
          "doc": "Index within the RowGroup of the first row of the page; this means pages\nchange on record boundaries (r = 0).\n",
          "required": "required"
        }
      ]
    },
    {
      "name": "OffsetIndex",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "page_locations",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "struct",
            "elemType": {
              "typeId": "struct",
              "class": "PageLocation"
            }
          },
          "doc": "PageLocations, ordered by increasing PageLocation.offset. It is required\nthat page_locations[i].first_row_index < page_locations[i+1].first_row_index.\n",
          "required": "required"
        }
      ]
    },
    {
      "name": "ColumnIndex",
      "doc": "Description for ColumnIndex.\nEach <array-field>[i] refers to the page at OffsetIndex.page_locations[i]\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "null_pages",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "bool"
          },
          "doc": "A list of Boolean values to determine the validity of the corresponding\nmin and max values. If true, a page contains only null values, and writers\nhave to set the corresponding entries in min_values and max_values to\nbyte[0], so that all lists have the same length. If false, the\ncorresponding entries in min_values and max_values must be valid.\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "min_values",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "binary"
          },
          "doc": "Two lists containing lower and upper bounds for the values of each page\ndetermined by the ColumnOrder of the column. These may be the actual\nminimum and maximum values found on a page, but can also be (more compact)\nvalues that do not exist on a page. For example, instead of storing \"\"Blart\nVersenwald III\", a writer may set min_values[i]=\"B\", max_values[i]=\"C\".\nSuch more compact values must still be valid values within the column's\nlogical type. Readers must make sure that list entries are populated before\nusing them by inspecting null_pages.\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "max_values",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "binary"
          },
          "required": "required"
        },
        {
          "key": 4,
          "name": "boundary_order",
          "typeId": "i32",
          "doc": "Stores whether both min_values and max_values are orderd and if so, in\nwhich direction. This allows readers to perform binary searches in both\nlists. Readers cannot assume that max_values[i] <= min_values[i+1], even\nif the lists are ordered.\n",
          "required": "required"
        },
        {
          "key": 5,
          "name": "null_counts",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "i64"
          },
          "doc": "A list containing the number of null values for each page *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "AesGcmV1",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "aad_prefix",
          "typeId": "binary",
          "doc": "AAD prefix *\n",
          "required": "optional"
        },
        {
          "key": 2,
          "name": "aad_file_unique",
          "typeId": "binary",
          "doc": "Unique file identifier part of AAD suffix *\n",
          "required": "optional"
        },
        {
          "key": 3,
          "name": "supply_aad_prefix",
          "typeId": "bool",
          "doc": "In files encrypted with AAD prefix without storing it,\nreaders must supply the prefix *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "AesGcmCtrV1",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "aad_prefix",
          "typeId": "binary",
          "doc": "AAD prefix *\n",
          "required": "optional"
        },
        {
          "key": 2,
          "name": "aad_file_unique",
          "typeId": "binary",
          "doc": "Unique file identifier part of AAD suffix *\n",
          "required": "optional"
        },
        {
          "key": 3,
          "name": "supply_aad_prefix",
          "typeId": "bool",
          "doc": "In files encrypted with AAD prefix without storing it,\nreaders must supply the prefix *\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "EncryptionAlgorithm",
      "isException": false,
      "isUnion": true,
      "fields": [
        {
          "key": 1,
          "name": "AES_GCM_V1",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "AesGcmV1"
          },
          "required": "optional"
        },
        {
          "key": 2,
          "name": "AES_GCM_CTR_V1",
          "typeId": "struct",
          "type": {
            "typeId": "struct",
            "class": "AesGcmCtrV1"
          },
          "required": "optional"
        }
      ]
    },
    {
      "name": "FileMetaData",
      "doc": "Description for file metadata\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "version",
          "typeId": "i32",
          "doc": "Version of this file *\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "schema",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "struct",
            "elemType": {
              "typeId": "struct",
              "class": "SchemaElement"
            }
          },
          "doc": "Parquet schema for this file.  This schema contains metadata for all the columns.\nThe schema is represented as a tree with a single root.  The nodes of the tree\nare flattened to a list by doing a depth-first traversal.\nThe column metadata contains the path in the schema for that column which can be\nused to map columns to nodes in the schema.\nThe first element is the root *\n",
          "required": "required"
        },
        {
          "key": 3,
          "name": "num_rows",
          "typeId": "i64",
          "doc": "Number of rows in this file *\n",
          "required": "required"
        },
        {
          "key": 4,
          "name": "row_groups",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "struct",
            "elemType": {
              "typeId": "struct",
              "class": "RowGroup"
            }
          },
          "doc": "Row groups in this file *\n",
          "required": "required"
        },
        {
          "key": 5,
          "name": "key_value_metadata",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "struct",
            "elemType": {
              "typeId": "struct",
              "class": "KeyValue"
            }
          },
          "doc": "Optional key\/value metadata *\n",
          "required": "optional"
        },
        {
          "key": 6,
          "name": "created_by",
          "typeId": "string",
          "doc": "String for application that wrote this file.  This should be in the format\n<Application> version <App Version> (build <App Build Hash>).\ne.g. impala version 1.0 (build 6cf94d29b2b7115df4de2c06e2ab4326d721eb55)\n\n",
          "required": "optional"
        },
        {
          "key": 7,
          "name": "column_orders",
          "typeId": "list",
          "type": {
            "typeId": "list",
            "elemTypeId": "union",
            "elemType": {
              "typeId": "union",
              "class": "ColumnOrder"
            }
          },
          "doc": "Sort order used for the min_value and max_value fields in the Statistics\nobjects and the min_values and max_values fields in the ColumnIndex\nobjects of each column in this file. Sort orders are listed in the order\nmatching the columns in the schema. The indexes are not necessary the same\nthough, because only leaf nodes of the schema are represented in the list\nof sort orders.\n\nWithout column_orders, the meaning of the min_value and max_value fields\nin the Statistics object and the ColumnIndex object is undefined. To ensure\nwell-defined behaviour, if these fields are written to a Parquet file,\ncolumn_orders must be written as well.\n\nThe obsolete min and max fields in the Statistics object are always sorted\nby signed comparison regardless of column_orders.\n",
          "required": "optional"
        },
        {
          "key": 8,
          "name": "encryption_algorithm",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "EncryptionAlgorithm"
          },
          "doc": "Encryption algorithm. This field is set only in encrypted files\nwith plaintext footer. Files with encrypted footer store algorithm id\nin FileCryptoMetaData structure.\n",
          "required": "optional"
        },
        {
          "key": 9,
          "name": "footer_signing_key_metadata",
          "typeId": "binary",
          "doc": "Retrieval metadata of key used for signing the footer.\nUsed only in encrypted files with plaintext footer.\n",
          "required": "optional"
        }
      ]
    },
    {
      "name": "FileCryptoMetaData",
      "doc": "Crypto metadata for files with encrypted footer *\n",
      "isException": false,
      "isUnion": false,
      "fields": [
        {
          "key": 1,
          "name": "encryption_algorithm",
          "typeId": "union",
          "type": {
            "typeId": "union",
            "class": "EncryptionAlgorithm"
          },
          "doc": "Encryption algorithm. This field is only used for files\nwith encrypted footer. Files with plaintext footer store algorithm id\ninside footer (FileMetaData structure).\n",
          "required": "required"
        },
        {
          "key": 2,
          "name": "key_metadata",
          "typeId": "binary",
          "doc": "Retrieval metadata of key used for encryption of footer,\nand (possibly) columns *\n",
          "required": "optional"
        }
      ]
    }
  ],
  "constants": [
  ],
  "services": [
  ]
}
