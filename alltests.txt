// src/Parquet.Test/Encryption/ReaderWiring_BloomTests.cs
using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption.ReaderWiring {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class BloomTests {
        private static readonly byte[] Key = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("bloom");
        private static readonly byte[] Unique = new byte[] { 7, 7, 7, 7 };
        private const short RG = 1, COL = 1;

        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        private static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            ms.Write(tag16, 0, tag16.Length);
            return ms.ToArray();
        }

        [Theory]
        [InlineData(ParquetModules.BloomFilter_Header)]
        [InlineData(ParquetModules.BloomFilter_Bitset)]
        public void Bloom_Modules_Decrypt_Via_Wiring(ParquetModules module) {
            byte[] payload = Encoding.ASCII.GetBytes($"bf-{module}");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] aad = Prefix
                .Concat(Unique)
                .Concat(new byte[] { (byte)module })
                .Concat(BitConverter.GetBytes(RG))
                .Concat(BitConverter.GetBytes(COL))
                .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            byte[] ct = new byte[payload.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, payload, ct, tag, aad);

            byte[] framed = FrameGcm(nonce, ct, tag);
            var decr = new AES_GCM_V1_Encryption {
                DecryptionKey = Key,
                AadPrefix = Prefix,
                AadFileUnique = Unique
            };

            byte[] outBytes = module == ParquetModules.BloomFilter_Header
                ? decr.BloomFilterHeader(R(framed), RG, COL)
                : decr.BloomFilterBitset(R(framed), RG, COL);

            Assert.Equal(payload, outBytes);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption.ReaderWiring {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class IndexesTests {
        private static readonly byte[] Key = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("idx");
        private static readonly byte[] Unique = new byte[] { 0x01, 0x02, 0x03, 0x04 };
        private const short RG = 0, COL = 2;

        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        private static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            ms.Write(tag16, 0, tag16.Length);
            return ms.ToArray();
        }

        [Theory]
        [InlineData(ParquetModules.ColumnIndex)]
        [InlineData(ParquetModules.OffsetIndex)]
        public void Index_Modules_Decrypt_Via_Wiring(ParquetModules module) {
            byte[] payload = Encoding.ASCII.GetBytes($"payload-{module}");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] aad = Prefix
                .Concat(Unique)
                .Concat(new byte[] { (byte)module })
                .Concat(BitConverter.GetBytes(RG))
                .Concat(BitConverter.GetBytes(COL))
                .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            byte[] ct = new byte[payload.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, payload, ct, tag, aad);

            byte[] framed = FrameGcm(nonce, ct, tag);
            var decr = new AES_GCM_V1_Encryption {
                DecryptionKey = Key,
                AadPrefix = Prefix,
                AadFileUnique = Unique
            };

            byte[] outBytes = module == ParquetModules.ColumnIndex
                ? decr.DecryptColumnIndex(R(framed), RG, COL)
                : decr.DecryptOffsetIndex(R(framed), RG, COL);

            Assert.Equal(payload, outBytes);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption.ReaderWiring {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class PageTests {
        private static readonly byte[] Key = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("hdr+page");
        private static readonly byte[] Unique = new byte[] { 0xFE, 0xED, 0xFA, 0xCE };
        private const short RG = 0, COL = 1, PAGE = 2;

        private static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            ms.Write(tag16, 0, tag16.Length);
            return ms.ToArray();
        }

        private static byte[] FrameCtr(byte[] nonce12, byte[] ciphertext) {
            int len = nonce12.Length + ciphertext.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            return ms.ToArray();
        }

        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        [Fact]
        public void AES_GCM_CTR_V1_Header_via_GCM_and_Page_via_CTR() {
            // --- Header (GCM) ---
            byte[] headerPlain = Encoding.ASCII.GetBytes("H");
            byte[] nonceH = RandomNumberGenerator.GetBytes(12);
            byte[] aadH = Prefix
                .Concat(Unique)
                .Concat(new byte[] { (byte)ParquetModules.Data_PageHeader })
                .Concat(BitConverter.GetBytes(RG))
                .Concat(BitConverter.GetBytes(COL))
                .Concat(BitConverter.GetBytes(PAGE))
                .ToArray();
#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            byte[] ctH = new byte[headerPlain.Length];
            byte[] tagH = new byte[16];
            gcm.Encrypt(nonceH, headerPlain, ctH, tagH, aadH);
            byte[] framedHeader = FrameGcm(nonceH, ctH, tagH);

            // --- Page (CTR) ---
            byte[] pagePlain = Encoding.ASCII.GetBytes("P");
            byte[] nonceP = RandomNumberGenerator.GetBytes(12);
            byte[] iv = new byte[16];
            Buffer.BlockCopy(nonceP, 0, iv, 0, 12);
            iv[12] = 0;
            iv[13] = 0;
            iv[14] = 0;
            iv[15] = 1;

            byte[] ctP;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                aes.Key = Key;
                using ICryptoTransform enc = aes.CreateEncryptor();
                ctP = XorCtr(enc, iv, pagePlain);
            }
            byte[] framedPage = FrameCtr(nonceP, ctP);

            var decr = new AES_GCM_CTR_V1_Encryption {
                DecryptionKey = Key,
                AadPrefix = Prefix,
                AadFileUnique = Unique
            };

            // Simulate the wiring:
            byte[] headerOut = decr.DecryptDataPageHeader(R(framedHeader), RG, COL, PAGE);
            byte[] pageOut = decr.DecryptDataPage(R(framedPage), RG, COL, PAGE);

            Assert.Equal(headerPlain, headerOut);
            Assert.Equal(pagePlain, pageOut);
        }

        private static byte[] XorCtr(ICryptoTransform ecbEncryptor, byte[] iv16, byte[] input) {
            byte[] counter = (byte[])iv16.Clone();
            byte[] output = new byte[input.Length];
            int i = 0;
            while(i < input.Length) {
                byte[] ks = new byte[16];
                ecbEncryptor.TransformBlock(counter, 0, 16, ks, 0);
                int n = Math.Min(16, input.Length - i);
                for(int j = 0; j < n; j++)
                    output[i + j] = (byte)(input[i + j] ^ ks[j]);
                for(int p = 15; p >= 12; p--)
                    if(++counter[p] != 0)
                        break;
                i += n;
            }
            return output;
        }
    }
}

// src/Parquet.Test/Encryption/PageOrdinal_Reset_Tests.cs
using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {

    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AadOrdinalTests {
        private static readonly byte[] Key = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("ord-reset");
        private static readonly byte[] Unique = new byte[] { 1, 3, 3, 7 };

        private static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            ms.Write(tag16, 0, tag16.Length);
            return ms.ToArray();
        }

        private static byte[] EncryptHeader(short rg, short col, short pageOrd, string txt) {
            byte[] plain = Encoding.ASCII.GetBytes(txt);
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] tag = new byte[16];
            byte[] ct = new byte[plain.Length];

            byte[] aad = Prefix
                .Concat(Unique)
                .Concat(new byte[] { (byte)ParquetModules.Data_PageHeader })
                .Concat(BitConverter.GetBytes(rg))
                .Concat(BitConverter.GetBytes(col))
                .Concat(BitConverter.GetBytes(pageOrd))
                .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            gcm.Encrypt(nonce, plain, ct, tag, aad);
            return FrameGcm(nonce, ct, tag);
        }

        [Fact]
        public void Ordinal_Resets_Per_Column_And_RowGroup() {
            var dec = new AES_GCM_V1_Encryption { DecryptionKey = Key, AadPrefix = Prefix, AadFileUnique = Unique };

            // RG0 COL0 page0
            byte[] rg0c0p0 = EncryptHeader(0, 0, 0, "rg0c0p0");
            Assert.Equal(Encoding.ASCII.GetBytes("rg0c0p0"),
                dec.DecryptDataPageHeader(R(rg0c0p0), 0, 0, 0));

            // RG0 COL0 page1
            byte[] rg0c0p1 = EncryptHeader(0, 0, 1, "rg0c0p1");
            Assert.Equal(Encoding.ASCII.GetBytes("rg0c0p1"),
                dec.DecryptDataPageHeader(R(rg0c0p1), 0, 0, 1));

            // RG0 COL1 page0 (ordinal resets to 0 for a new column)
            byte[] rg0c1p0 = EncryptHeader(0, 1, 0, "rg0c1p0");
            Assert.Equal(Encoding.ASCII.GetBytes("rg0c1p0"),
                dec.DecryptDataPageHeader(R(rg0c1p0), 0, 1, 0));

            // RG1 COL0 page0 (ordinal resets to 0 for a new row group)
            byte[] rg1c0p0 = EncryptHeader(1, 0, 0, "rg1c0p0");
            Assert.Equal(Encoding.ASCII.GetBytes("rg1c0p0"),
                dec.DecryptDataPageHeader(R(rg1c0p0), 1, 0, 0));

            // Negative checks: wrong ordinals/rg/col must fail
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(rg0c0p0), 0, 0, 1));
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(rg0c1p0), 0, 0, 0));
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(rg1c0p0), 0, 0, 0));
        }

        private static byte[] Frame(byte[] n, byte[] c, byte[] t) {
            int len = n.Length + c.Length + t.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(n, 0, n.Length);
            ms.Write(c, 0, c.Length);
            ms.Write(t, 0, t.Length);
            return ms.ToArray();
        }
        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        [Fact]
        public void ColumnOrdinal_Is_Enforced() {
            byte[] plain = Encoding.ASCII.GetBytes("hdr");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] tag = new byte[16];
            byte[] ct = new byte[plain.Length];

            // Encrypt for column 0
            byte[] aad = Prefix
                .Concat(Unique)
                .Concat(new byte[] { (byte)ParquetModules.Data_PageHeader })
                .Concat(BitConverter.GetBytes((short)0)) // rg
                .Concat(BitConverter.GetBytes((short)0)) // col 0
                .Concat(BitConverter.GetBytes((short)0)) // page 0
                .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            gcm.Encrypt(nonce, plain, ct, tag, aad);
            byte[] framed = Frame(nonce, ct, tag);

            var dec = new AES_GCM_V1_Encryption { DecryptionKey = Key, AadPrefix = Prefix, AadFileUnique = Unique };

            // Correct column works
            Assert.Equal(plain, dec.DecryptDataPageHeader(R(framed), 0, 0, 0));

            // Wrong column fails
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(framed), 0, 1, 0));
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AadPrefixBehaviorTests {
        private static readonly byte[] Key = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] FileUnique = new byte[] { 1, 2, 3, 4 };
        private const short RG = 0, COL = 0;

        private static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            ms.Write(tag16, 0, tag16.Length);
            return ms.ToArray();
        }
        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        [Fact]
        public void Uses_Stored_AadPrefix_When_SupplyAadPrefix_False() {
            byte[] storedPrefix = Encoding.ASCII.GetBytes("stored-prefix");
            byte[] plaintext = Encoding.ASCII.GetBytes("col-metadata");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // AAD = storedPrefix || (fileUnique || module || RG || COL)
            byte[] aadSuffix = new byte[] { }
                .Concat(FileUnique)
                .Concat(new byte[] { (byte)ParquetModules.ColumnMetaData })
                .Concat(BitConverter.GetBytes(RG))
                .Concat(BitConverter.GetBytes(COL))
                .ToArray();
            byte[] aad = storedPrefix.Concat(aadSuffix).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            var enc = new AES_GCM_V1_Encryption {
                DecryptionKey = Key,
                AadPrefix = storedPrefix,        // stored value, not supplied
                AadFileUnique = FileUnique
            };

            byte[] framed = FrameGcm(nonce, ct, tag);
            byte[] outBytes = enc.DecryptColumnMetaData(R(framed), RG, COL);
            Assert.Equal(plaintext, outBytes);
        }

        [Fact]
        public void Missing_Supplied_AadPrefix_Fails_Cleanly() {
            // Build bytes with a *required* supplied prefix "runtime-prefix"
            byte[] suppliedPrefix = Encoding.ASCII.GetBytes("runtime-prefix");
            byte[] plaintext = Encoding.ASCII.GetBytes("offset-index");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            byte[] aadSuffix = new byte[] { }
                .Concat(FileUnique)
                .Concat(new byte[] { (byte)ParquetModules.OffsetIndex })
                .Concat(BitConverter.GetBytes(RG))
                .Concat(BitConverter.GetBytes(COL))
                .ToArray();
            byte[] aad = suppliedPrefix.Concat(aadSuffix).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            // Simulate caller forgetting to provide the supplied prefix (AadPrefix = null/empty)
            var enc = new AES_GCM_V1_Encryption {
                DecryptionKey = Key,
                AadPrefix = Array.Empty<byte>(),
                AadFileUnique = FileUnique
            };

            byte[] framed = FrameGcm(nonce, ct, tag);

            // Wrong AAD -> Auth tag mismatch (platform may throw AuthenticationTagMismatchException or CryptographicException)
            Assert.ThrowsAny<CryptographicException>(() => {
                enc.DecryptOffsetIndex(R(framed), RG, COL);
            });
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AadSuffixModuleTests {
        private static readonly byte[] Key128 = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] AadPrefix = Encoding.ASCII.GetBytes("aad_prefix_idx");
        private static readonly byte[] AadFileUnique = new byte[] { 0xDE, 0xAD, 0xBE, 0xEF };
        private const short RG = 2, COL = 4, PAGE = 0;

        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));
        private static byte[] Le(short v) => BitConverter.GetBytes(v);

        private static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            ms.Write(tag16, 0, tag16.Length);
            return ms.ToArray();
        }

        private static byte[] BuildAad(byte module, short? rg, short? col, short? page = null) {
            using var ms = new MemoryStream();
            ms.Write(AadPrefix, 0, AadPrefix.Length);
            // suffix:
            ms.Write(AadFileUnique, 0, AadFileUnique.Length);
            ms.WriteByte(module);
            if(rg.HasValue)
                ms.Write(Le(rg.Value), 0, 2);
            if(col.HasValue)
                ms.Write(Le(col.Value), 0, 2);
            if(page.HasValue)
                ms.Write(Le(page.Value), 0, 2);
            return ms.ToArray();
        }

        private static byte[] EncryptGcm(byte[] key, byte[] aad, byte[] plaintext, out byte[] nonce, out byte[] tag) {
            nonce = RandomNumberGenerator.GetBytes(12);
            tag = new byte[16];
            byte[] ct = new byte[plaintext.Length];
#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(key, 16);
#else
            using var gcm = new AesGcm(key);
#endif
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);
            return ct;
        }

        [Theory]
        [InlineData(ParquetModules.ColumnIndex)]
        [InlineData(ParquetModules.OffsetIndex)]
        [InlineData(ParquetModules.BloomFilter_Header)]
        [InlineData(ParquetModules.BloomFilter_Bitset)]
        [InlineData(ParquetModules.ColumnMetaData)]
        public void NonPage_Modules_Decrypt_With_Correct_AAD(ParquetModules module) {
            byte[] plaintext = Encoding.ASCII.GetBytes($"ok-{module}");
            byte[] aad = BuildAad((byte)module, RG, COL);
            byte[] ct = EncryptGcm(Key128, aad, plaintext, out byte[]? nonce, out byte[]? tag);
            byte[] framed = FrameGcm(nonce, ct, tag);

            var enc = new AES_GCM_V1_Encryption {
                DecryptionKey = Key128,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            byte[] result = module switch {
                ParquetModules.ColumnIndex => enc.DecryptColumnIndex(R(framed), RG, COL),
                ParquetModules.OffsetIndex => enc.DecryptOffsetIndex(R(framed), RG, COL),
                ParquetModules.BloomFilter_Header => enc.BloomFilterHeader(R(framed), RG, COL),
                ParquetModules.BloomFilter_Bitset => enc.BloomFilterBitset(R(framed), RG, COL),
                ParquetModules.ColumnMetaData => enc.DecryptColumnMetaData(R(framed), RG, COL),
                _ => throw new NotSupportedException()
            };

            Assert.Equal(plaintext, result);
        }

        [Fact]
        public void Wrong_Ordinal_Endianness_Fails() {
            // Use ColumnIndex as an example; flip endianness of RG
            ParquetModules module = ParquetModules.ColumnIndex;
            byte[] plaintext = Encoding.ASCII.GetBytes("bad-aad");

            // Build a wrong AAD where row group is BE instead of LE
            using var ms = new MemoryStream();
            ms.Write(AadPrefix, 0, AadPrefix.Length);
            ms.Write(AadFileUnique, 0, AadFileUnique.Length);
            ms.WriteByte((byte)module);
            // WRONG: big-endian write of RG
            byte[] rgBE = BitConverter.GetBytes((ushort)RG);
            Array.Reverse(rgBE);
            ms.Write(rgBE, 0, 2);
            // correct LE for COL (so we isolate the failure to RG)
            ms.Write(Le(COL), 0, 2);
            byte[] wrongAad = ms.ToArray();

            byte[] ct = EncryptGcm(Key128, wrongAad, plaintext, out byte[]? nonce, out byte[]? tag);
            byte[] framed = FrameGcm(nonce, ct, tag);

            var enc = new AES_GCM_V1_Encryption {
                DecryptionKey = Key128,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            Assert.ThrowsAny<CryptographicException>(() => {
                enc.DecryptColumnIndex(R(framed), RG, COL);
            });
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class AesCtrBehaviorTests {
        private static readonly byte[] Key256 = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] AadPrefix = Encoding.ASCII.GetBytes("spec_ctr_split");
        private static readonly byte[] AadFileUnique = new byte[] { 0x10, 0x20, 0x30, 0x40 };
        private const short RG = 5, COL = 9, PAGE = 1;

        private static ThriftCompactProtocolReader Reader(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        private static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            ms.Write(tag16, 0, tag16.Length);
            return ms.ToArray();
        }

        private static byte[] FrameCtr(byte[] nonce12, byte[] ciphertext) {
            int len = nonce12.Length + ciphertext.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            return ms.ToArray();
        }

        private static byte[] AadSuffix(byte module, short? rg, short? col, short? page) {
            using var ms = new MemoryStream();
            ms.Write(AadFileUnique, 0, AadFileUnique.Length);
            ms.WriteByte(module);
            if(rg.HasValue)
                ms.Write(BitConverter.GetBytes(rg.Value), 0, 2);
            if(col.HasValue)
                ms.Write(BitConverter.GetBytes(col.Value), 0, 2);
            if(page.HasValue)
                ms.Write(BitConverter.GetBytes(page.Value), 0, 2);
            return ms.ToArray();
        }

        [Fact]
        public void DataPage_Uses_CTR_Framing_And_Decrypts() {
            byte[] plaintext = Encoding.ASCII.GetBytes("ctr-page-bytes");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // Build 16-byte IV = nonce || 0x00000001
            byte[] iv = new byte[16];
            Buffer.BlockCopy(nonce, 0, iv, 0, 12);
            iv[12] = 0;
            iv[13] = 0;
            iv[14] = 0;
            iv[15] = 1;

            // Encrypt via CTR keystream (ECB)
            byte[] ciphertext;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                aes.Key = Key256;
                using ICryptoTransform enc = aes.CreateEncryptor();
                ciphertext = XorWithCtr(enc, iv, plaintext);
            }

            byte[] framed = FrameCtr(nonce, ciphertext);
            var encCtr = new AES_GCM_CTR_V1_Encryption {
                DecryptionKey = Key256,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            byte[] outBytes = encCtr.DecryptDataPage(Reader(framed), RG, COL, PAGE);
            Assert.Equal(plaintext, outBytes);
        }

        [Fact]
        public void DataPageHeader_Stays_GCM_And_Decrypts() {
            byte[] plaintext = Encoding.ASCII.GetBytes("gcm-header");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            byte[] aad = AadPrefix.Concat(AadSuffix((byte)ParquetModules.Data_PageHeader, RG, COL, PAGE)).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key256, 16);
#else
            using var gcm = new AesGcm(Key256);
#endif
            byte[] ct = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ct, tag, aad);

            byte[] framed = FrameGcm(nonce, ct, tag);

            var encCtr = new AES_GCM_CTR_V1_Encryption {
                DecryptionKey = Key256,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            byte[] outBytes = encCtr.DecryptDataPageHeader(Reader(framed), RG, COL, PAGE);
            Assert.Equal(plaintext, outBytes);
        }

        [Fact]
        public void DataPageHeader_With_CTR_Framing_Is_Rejected() {
            // GCM is required for headers; feeding CTR-framed bytes should fail the GCM framing checks
            byte[] bogusHdr = Encoding.ASCII.GetBytes("hdr");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // Make CTR ciphertext
            byte[] iv = new byte[16];
            Buffer.BlockCopy(nonce, 0, iv, 0, 12);
            iv[12] = 0;
            iv[13] = 0;
            iv[14] = 0;
            iv[15] = 1;
            byte[] ciphertext;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                aes.Key = Key256;
                using ICryptoTransform enc = aes.CreateEncryptor();
                ciphertext = XorWithCtr(enc, iv, bogusHdr);
            }

            byte[] framed = FrameCtr(nonce, ciphertext);
            var encCtr = new AES_GCM_CTR_V1_Encryption {
                DecryptionKey = Key256,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            Assert.Throws<InvalidDataException>(() => {
                encCtr.DecryptDataPageHeader(Reader(framed), RG, COL, PAGE);
            });
        }

        private static byte[] XorWithCtr(ICryptoTransform ecbEncryptor, byte[] iv16, byte[] input) {
            byte[] counter = (byte[])iv16.Clone();
            byte[] output = new byte[input.Length];
            int i = 0;
            while(i < input.Length) {
                byte[] ks = new byte[16];
                ecbEncryptor.TransformBlock(counter, 0, 16, ks, 0);

                int n = Math.Min(16, input.Length - i);
                for(int j = 0; j < n; j++)
                    output[i + j] = (byte)(input[i + j] ^ ks[j]);

                // increment last 4 bytes (big-endian)
                for(int p = 15; p >= 12; p--)
                    if(++counter[p] != 0)
                        break;
                i += n;
            }
            return output;
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class ColumnEncryptionE2ETests : TestBase {
        private static ParquetSchema MakeSchema()
            => new ParquetSchema(new DataField<string>("s"));

        [Fact]
        public async Task A_PageEncryption_GcmV1_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                EncryptionKey = Convert.ToBase64String(Enumerable.Range(1, 16).Select(i => (byte)i).ToArray()),
                AADPrefix = "suite-a",
                SupplyAadPrefix = false,     // store prefix in file
                UseCtrVariant = false        // GCM profile
            };

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                var sField = (DataField)schema.Fields[0];
                await rg.WriteColumnAsync(new DataColumn(sField, new[] { "x", "y", "z" }));
            }

            ms.Position = 0;
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                EncryptionKey = opts.EncryptionKey
            });

            Assert.True(reader.IsEncryptedFile);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var rf = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(rf);
            Assert.Equal(new[] { "x", "y", "z" }, col.Data);
        }

        [Fact]
        public async Task B_PageEncryption_CtrVariant_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                EncryptionKey = "sixteen-byte-key",  // 16 bytes UTF-8
                AADPrefix = "suite-b",
                SupplyAadPrefix = false,
                UseCtrVariant = true                 // CTR bodies, GCM headers
            };

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                var sField = (DataField)schema.Fields[0];
                await rg.WriteColumnAsync(new DataColumn(sField, Enumerable.Range(0, 100).Select(i => i.ToString()).ToArray()));
            }

            ms.Position = 0;
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                EncryptionKey = opts.EncryptionKey
            });

            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var rf = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(rf);
            Assert.Equal(100, col.Data.Length);
            Assert.Equal("0", (string)col.Data.GetValue(0)!);
            Assert.Equal("99", (string)col.Data.GetValue(99)!);
        }

        [Fact]
        public async Task C_PageEncryption_MissingPrefix_Fails_When_SupplyAadPrefix_True() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                EncryptionKey = Convert.ToBase64String(Enumerable.Range(1, 32).Select(i => (byte)i).ToArray()),
                AADPrefix = "require-supply",
                SupplyAadPrefix = true,          // do not store prefix in file
                UseCtrVariant = false
            };

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                var sField = (DataField)schema.Fields[0];
                await rg.WriteColumnAsync(new DataColumn(sField, new[] { "a", "b" }));
            }

            ms.Position = 0;
            await Assert.ThrowsAsync<InvalidDataException>(async () => {
                using ParquetReader _ = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                    EncryptionKey = opts.EncryptionKey,
                    AADPrefix = null     // not supplied -> should fail
                });
            });
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class EncryptionPrimitives_WriteTests {
        private static readonly byte[] Key16 = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] Key32 = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("writer-aad");
        private static readonly byte[] Unique = new byte[] { 0x10, 0x20, 0x30, 0x40 };

        private static ThriftCompactProtocolReader R(byte[] buf)
            => new ThriftCompactProtocolReader(new MemoryStream(buf));

        private static AES_GCM_V1_Encryption MakeGcm(byte[] key) => new AES_GCM_V1_Encryption {
            DecryptionKey = key,
            AadPrefix = Prefix,
            AadFileUnique = Unique
        };

        private static AES_GCM_CTR_V1_Encryption MakeCtr(byte[] key) => new AES_GCM_CTR_V1_Encryption {
            DecryptionKey = key,
            AadPrefix = Prefix,
            AadFileUnique = Unique
        };

        [Fact]
        public void Gcm_Footer_Encrypt_RoundTrip() {
            AES_GCM_V1_Encryption enc = MakeGcm(Key32);
            AES_GCM_V1_Encryption dec = MakeGcm(Key32);
            byte[] plain = Encoding.ASCII.GetBytes("footer-bytes");

            // encrypt
            byte[] framed = enc.EncryptFooter(plain);

            // decrypt
            byte[] outBytes = dec.DecryptFooter(R(framed));
            Assert.Equal(plain, outBytes);
        }

        [Fact]
        public void Gcm_DataPageHeader_Encrypt_RoundTrip_With_PageOrdinal() {
            AES_GCM_V1_Encryption enc = MakeGcm(Key16);
            AES_GCM_V1_Encryption dec = MakeGcm(Key16);
            byte[] plain = Encoding.ASCII.GetBytes("hdr-0");

            short rg = 2, col = 3, page = 0;
            byte[] framed = enc.EncryptDataPageHeader(plain, rg, col, page);
            byte[] outBytes = dec.DecryptDataPageHeader(R(framed), rg, col, page);
            Assert.Equal(plain, outBytes);

            // wrong ordinal fails
            Assert.ThrowsAny<CryptographicException>(() =>
                dec.DecryptDataPageHeader(R(framed), rg, col, 1));
        }

        [Fact]
        public void Gcm_DataPageBody_Encrypt_RoundTrip() {
            var gcm = new AES_GCM_V1_Encryption {
                DecryptionKey = Key16,
                AadPrefix = Encoding.ASCII.GetBytes("writer-aad"),
                AadFileUnique = new byte[] { 0x10, 0x20, 0x30, 0x40 }
            };

            byte[] plain = Enumerable.Range(0, 257).Select(i => (byte)i).ToArray();
            short rg = 0, col = 0, page = 5;

            byte[] framed = gcm.EncryptDataPage(plain, rg, col, page);
            byte[] outBytes = gcm.DecryptDataPage(R(framed), rg, col, page);

            Assert.Equal(plain, outBytes);
        }



        [Fact]
        public void Ctr_DataPageBody_Encrypt_RoundTrip() {
            AES_GCM_CTR_V1_Encryption enc = MakeCtr(Key32);
            AES_GCM_CTR_V1_Encryption dec = MakeCtr(Key32);
            byte[] plain = Enumerable.Range(0, 999).Select(i => (byte)(i % 251)).ToArray();

            short rg = 1, col = 1, page = 9;
            byte[] framed = enc.EncryptDataPage(plain, rg, col, page); // CTR framing
            byte[] outBytes = dec.DecryptDataPage(R(framed), rg, col, page);
            Assert.Equal(plain, outBytes);
        }

        [Theory]
        [InlineData(ParquetModules.ColumnMetaData)]
        [InlineData(ParquetModules.ColumnIndex)]
        [InlineData(ParquetModules.OffsetIndex)]
        [InlineData(ParquetModules.BloomFilter_Header)]
        [InlineData(ParquetModules.BloomFilter_Bitset)]
        public void Gcm_Module_Encrypt_RoundTrip(ParquetModules module) {
            AES_GCM_V1_Encryption enc = MakeGcm(Key16);
            AES_GCM_V1_Encryption dec = MakeGcm(Key16);
            byte[] plain = Encoding.ASCII.GetBytes($"mod-{module}");
            short rg = 7, col = 4;

            byte[] framed = enc.EncryptModuleGcm(plain, module, rg, col);
            byte[] outBytes = module switch {
                ParquetModules.ColumnMetaData => dec.DecryptColumnMetaData(R(framed), rg, col),
                ParquetModules.ColumnIndex => dec.DecryptColumnIndex(R(framed), rg, col),
                ParquetModules.OffsetIndex => dec.DecryptOffsetIndex(R(framed), rg, col),
                ParquetModules.BloomFilter_Header => dec.BloomFilterHeader(R(framed), rg, col),
                ParquetModules.BloomFilter_Bitset => dec.BloomFilterBitset(R(framed), rg, col),
                _ => throw new NotSupportedException()
            };
            Assert.Equal(plain, outBytes);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Threading.Tasks;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    public class EncryptionPrimitivesTests {
        // --- Shared fixtures ---
        private static readonly byte[] Key128 = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();
        private static readonly byte[] Key256 = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] AadPrefix = Encoding.ASCII.GetBytes("employees_2025-09-27.part0");
        private static readonly byte[] AadFileUnique = new byte[] { 0xAA, 0xBB, 0xCC, 0xDD }; // short is fine—spec allows impl-defined length
        private const short RowGroup = 3;
        private const short Column = 2;
        private const short Page = 7;

        private static byte[] Le16(short v) => BitConverter.GetBytes(v);

        private static byte[] BuildAadSuffix(ParquetModules module, bool addRowCol, bool addPage) {
            // AAD suffix = fileUnique || moduleType(1B) || [rowGroup(LE16)] || [column(LE16)] || [page(LE16)]
            using var ms = new MemoryStream();
            ms.Write(AadFileUnique, 0, AadFileUnique.Length);
            ms.WriteByte((byte)module);
            if(addRowCol) {
                ms.Write(Le16(RowGroup), 0, 2);
                ms.Write(Le16(Column), 0, 2);
            }
            if(addPage) {
                ms.Write(Le16(Page), 0, 2);
            }
            return ms.ToArray();
        }

        private static ThriftCompactProtocolReader MakeReader(byte[] buffer) {
            var ms = new MemoryStream(buffer);
            return new ThriftCompactProtocolReader(ms);
        }

        private static byte[] FrameGcmBuffer(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            // length = nonce + ciphertext + tag
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);              // 4B little-endian length
            ms.Write(nonce12, 0, nonce12.Length);                    // 12B nonce
            ms.Write(ciphertext, 0, ciphertext.Length);              // ciphertext
            ms.Write(tag16, 0, tag16.Length);                        // 16B tag
            return ms.ToArray();
        }

        private static byte[] FrameCtrBuffer(byte[] nonce12, byte[] ciphertext) {
            int len = nonce12.Length + ciphertext.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            return ms.ToArray();
        }

        // --- AES_GCM_V1 ---

        [Fact]
        public void AES_GCM_V1_RoundTrip_DataPage_WithAAD_Succeeds() {
            // Arrange
            byte[] plaintext = Encoding.ASCII.GetBytes("hello world, this is a data page payload!");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            byte[] aad = AadPrefix.Concat(BuildAadSuffix(ParquetModules.Data_Page, addRowCol: true, addPage: true)).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key256, 16);
#else
            using var gcm = new AesGcm(Key256);
#endif
            byte[] ciphertext = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ciphertext, tag, aad);

            byte[] framed = FrameGcmBuffer(nonce, ciphertext, tag);
            ThriftCompactProtocolReader reader = MakeReader(framed);

            var enc = new AES_GCM_V1_Encryption {
                DecryptionKey = Key256,
                AadPrefix = AadPrefix,
                AadFileUnique = AadFileUnique
            };

            // Act
            byte[] result = enc.DecryptDataPage(reader, RowGroup, Column, Page);

            // Assert
            Assert.Equal(plaintext, result);
        }

        [Fact]
        public void AES_GCM_V1_WrongAadPrefix_Throws() {
            // Arrange
            byte[] plaintext = Encoding.ASCII.GetBytes("column index payload");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            byte[] correctAad = AadPrefix.Concat(BuildAadSuffix(ParquetModules.ColumnIndex, addRowCol: true, addPage: false)).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key128, 16);
#else
            using var gcm = new AesGcm(Key128);
#endif
            byte[] ciphertext = new byte[plaintext.Length];
            byte[] tag = new byte[16];
            gcm.Encrypt(nonce, plaintext, ciphertext, tag, correctAad);

            byte[] framed = FrameGcmBuffer(nonce, ciphertext, tag);
            ThriftCompactProtocolReader reader = MakeReader(framed);

            byte[] wrongPrefix = Encoding.ASCII.GetBytes("WRONG_PREFIX");
            var enc = new AES_GCM_V1_Encryption {
                DecryptionKey = Key128,
                AadPrefix = wrongPrefix,       // <-- wrong on purpose
                AadFileUnique = AadFileUnique
            };

            // Act + Assert
            Assert.ThrowsAny<CryptographicException>(() => {
                enc.DecryptColumnIndex(reader, RowGroup, Column);
            });
        }

        // --- AES_GCM_CTR_V1 (pages only use CTR) ---
        // NOTE: This test describes the expected behavior per spec.
        // It will FAIL with the current implementation because the IV is 16 bytes,
        // not 12, and must be nonce(12) || counter(4) with first 31 bits 0 and last bit 1.

        [Fact]
        public void AES_GCM_CTR_V1_RoundTrip_DataPage_Uses16ByteIV_Succeeds_AfterFix() {
            // Arrange
            byte[] plaintext = Encoding.ASCII.GetBytes("fast CTR page data payload");
            byte[] nonce = RandomNumberGenerator.GetBytes(12);

            // Build 16-byte IV = nonce(12) || counter(4) where counter = 0x00000001 (big-endian)
            byte[] iv16 = new byte[16];
            Buffer.BlockCopy(nonce, 0, iv16, 0, 12);
            iv16[12] = 0x00;
            iv16[13] = 0x00;
            iv16[14] = 0x00;
            iv16[15] = 0x01; // last bit set

            // Encrypt with AES-CTR (ECB keystream on IV, increment counter big-endian)
            byte[] ciphertext;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                using ICryptoTransform encryptor = aes.CreateEncryptor(Key256, new byte[16]); // IV not used in ECB
                ciphertext = XorWithCtrKeystream(encryptor, iv16, plaintext);
            }

            byte[] framed = FrameCtrBuffer(nonce, ciphertext);
            ThriftCompactProtocolReader reader = MakeReader(framed);

            var enc = new AES_GCM_CTR_V1_Encryption {
                DecryptionKey = Key256,
                AadPrefix = AadPrefix,       // not used by CTR pages, but harmless
                AadFileUnique = AadFileUnique
            };

            // Act
            byte[] result = enc.DecryptDataPage(reader, RowGroup, Column, Page);

            // Assert
            Assert.Equal(plaintext, result);
        }

        // --- Magic bytes detection ---

        [Fact]
        public async Task ValidateFileAsync_SetsIsEncryptedFile_ForPARE() {
            // Arrange:  PARE .... PARE
            using var ms = new MemoryStream();
            ms.Write(Encoding.ASCII.GetBytes("PARE"), 0, 4);              // head
            ms.Write(new byte[] { 0, 1, 2, 3, 4, 5 }, 0, 6);              // body filler
            ms.Write(Encoding.ASCII.GetBytes("PARE"), 0, 4);              // tail
            ms.Position = 0;

            var actor = new TestParquetActor(ms);

            // Act
            await actor.CallValidateFileAsync();

            // Assert
            Assert.True(actor.IsEncryptedFile);
        }

        // --- Helpers ---

        // Re-usable CTR keystream xorer for test encryption
        private static byte[] XorWithCtrKeystream(ICryptoTransform ecbEncryptor, byte[] iv16, byte[] input) {
            int blockSize = 16;
            byte[] counter = (byte[])iv16.Clone();
            byte[] output = new byte[input.Length];

            int i = 0;
            while(i < input.Length) {
                byte[] ksBlock = new byte[blockSize];
                ecbEncryptor.TransformBlock(counter, 0, blockSize, ksBlock, 0);

                int n = Math.Min(blockSize, input.Length - i);
                for(int j = 0; j < n; j++) {
                    output[i + j] = (byte)(input[i + j] ^ ksBlock[j]);
                }

                // Increment counter big-endian in the last 4 bytes
                for(int p = 15; p >= 12; p--) {
                    if(++counter[p] != 0)
                        break;
                }

                i += n;
            }

            return output;
        }

        // Expose ValidateFileAsync via a tiny test shim
        private sealed class TestParquetActor : ParquetActor {
            public TestParquetActor(Stream s) : base(s) { }
            public new bool IsEncryptedFile => base.IsEncryptedFile;
            public Task CallValidateFileAsync() => base.ValidateFileAsync();
        }
    }
}

// src/Parquet.Test/Encryption/FramingValidationTests.cs
using System;
using System.IO;
using System.Linq;
using Parquet.Encryption;
using Parquet.Meta.Proto;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class FramingValidationTests {
        private static readonly byte[] Key = Enumerable.Range(1, 16).Select(i => (byte)i).ToArray();

        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        [Fact]
        public void Gcm_Framing_Too_Short_Throws_InvalidData() {
            // length smaller than nonce(12)+tag(16)
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(8), 0, 4); // impossible total
            ms.Write(new byte[8], 0, 8);
            var enc = new AES_GCM_V1_Encryption { DecryptionKey = Key, AadFileUnique = new byte[] { 1 } };

            Assert.Throws<InvalidDataException>(() =>
                enc.DecryptColumnIndex(R(ms.ToArray()), 0, 0));
        }

        [Fact]
        public void Ctr_Framing_Negative_Ciphertext_Throws_InvalidData() {
            // For CTR: total < nonce(12) => negative ciphertext length
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(10), 0, 4); // < 12
            ms.Write(new byte[10], 0, 10);
            var enc = new AES_GCM_CTR_V1_Encryption { DecryptionKey = Key, AadFileUnique = new byte[] { 1 } };

            Assert.Throws<InvalidDataException>(() =>
                enc.DecryptDataPage(R(ms.ToArray()), 0, 0, 0));
        }
    }
}

// src/Parquet.Test/Encryption/InteropWithParquetMrTests.cs
using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class InteropWithParquetMrTests : TestBase {
        [Fact]
        public async Task A_FooterOnly_NoPrefix_Succeeds() {
            using Stream s = OpenTestFile("encryption/enc_footer_only.parquet");
            var opts = new ParquetOptions {
                EncryptionKey = "footerKey-16byte",
                AADPrefix = null
            };
            using ParquetReader r = await ParquetReader.CreateAsync(s, opts);
            using ParquetRowGroupReader rg = r.OpenRowGroupReader(0);

            DataField df = r.Schema.DataFields.First();
            DataColumn col = await rg.ReadColumnAsync(df);
            Assert.NotEmpty(col.Data); // sanity
        }

        [Fact]
        public async Task B1_Missing_AadPrefix_throws_InvalidDataException() {
            using Stream s = OpenTestFile("encryption/enc_footer_with_aadprefix.parquet");
            var opts = new ParquetOptions {
                EncryptionKey = "footerKey-16byte",
                AADPrefix = null // missing
            };

            await Assert.ThrowsAsync<InvalidDataException>(async () => {
                using ParquetReader r = await ParquetReader.CreateAsync(s, opts);
            });
        }

        [Fact]
        public async Task B2_Wrong_AadPrefix_throws_CryptographicException() {
            using Stream s = OpenTestFile("encryption/enc_footer_with_aadprefix.parquet");
            var opts = new ParquetOptions {
                EncryptionKey = "footerKey-16byte",
                AADPrefix = "wr-fixtures-suiteX" // wrong bytes
            };

            await Assert.ThrowsAnyAsync<CryptographicException>(async () => {
                using ParquetReader r = await ParquetReader.CreateAsync(s, opts);
            });
        }


        [Fact]
        public async Task B_WithAadPrefix_CorrectPrefix_Succeeds() {
            using Stream s = OpenTestFile("encryption/enc_footer_with_aadprefix.parquet");
            var good = new ParquetOptions {
                EncryptionKey = "footerKey-16byte",
                AADPrefix = "wr-fixtures-suite"
            };
            using ParquetReader r = await ParquetReader.CreateAsync(s, good);
            using ParquetRowGroupReader rg = r.OpenRowGroupReader(0);
            DataField df = r.Schema.DataFields.First();
            DataColumn col = await rg.ReadColumnAsync(df);
            Assert.NotEmpty(col.Data);
        }

        [Fact]
        public async Task C_ColumnKey_NotSupported_Throws() {
            using Stream s = OpenTestFile("encryption/enc_footer_and_idcol.parquet");
            var opts = new ParquetOptions {
                EncryptionKey = "footerKey-16byte",
                AADPrefix = "wr-fixtures-suite"
            };
            await Assert.ThrowsAsync<NotSupportedException>(async () => {
                using ParquetReader r = await ParquetReader.CreateAsync(s, opts);
                using ParquetRowGroupReader rg = r.OpenRowGroupReader(0);
                DataField df = r.Schema.DataFields.First();
                _ = await rg.ReadColumnAsync(df);
            });
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class KeyParsingTests : TestBase {
        private static ThriftCompactProtocolReader DummyReader(params byte[] bytes)
            => new ThriftCompactProtocolReader(new MemoryStream(bytes));

        [Theory]
        [InlineData(16)]
        [InlineData(24)]
        [InlineData(32)]
        public void Base64_Key_Sizes_Accepted(int size) {
            byte[] keyBytes = Enumerable.Range(1, size).Select(i => (byte)i).ToArray();
            byte[] fileUnique = new byte[] { 5, 6, 7, 8 };
            string keyString = Convert.ToBase64String(keyBytes);

            // build a minimal FileCryptoMetaData with AESGCMV1 to drive DecryptFooter’s selection path;
            // we don’t actually decrypt; we just want decrypter setup to parse the key.
            var meta = new Meta.FileCryptoMetaData {
                EncryptionAlgorithm = new Meta.EncryptionAlgorithm {
                    AESGCMV1 = new Meta.AesGcmV1 {
                        AadFileUnique = fileUnique,
                        SupplyAadPrefix = false,
                        AadPrefix = Array.Empty<byte>()
                    }
                }
            };

            using MemoryStream ms = BuildStreamWithMetaAndEmptyEncryptedFooter(meta, keyBytes, aadPrefix: null, fileUnique: fileUnique);

            // Serialize meta and then call AES_GCM_V1_Encryption.Decrypt(...) indirectly is overkill;
            // instead, directly validate the parser via the class: we simulate by constructing
            // and setting the key with ParseKeyString behavior exposed via DecryptFooter.
            // So we just assert ParseKeyString would accept Base64 by invoking the whole flow:
            var protoWriter = new ThriftCompactProtocolWriter(ms);
            meta.Write(protoWriter);
            ms.Position = 0;

            var reader = new ThriftCompactProtocolReader(ms);

            byte[] footer = EncryptionBase.DecryptFooter(reader, keyString, aadPrefix: null, out EncryptionBase? decrypter);

            // We don't care about 'footer' value here (we didn't pass a real footer),
            // we care that we got to this point without an ArgumentException on key size.
            Assert.NotNull(decrypter);
            Assert.True(decrypter is AES_GCM_V1_Encryption or AES_GCM_CTR_V1_Encryption);
        }

        [Fact]
        public void Hex_Key_256_Accepted() {
            byte[] keyBytes = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
            byte[] fileUnique = new byte[] { 7, 7, 7, 7 };
            string keyString = Convert.ToBase64String(keyBytes);

            // 32 bytes (256-bit) hex
            var meta = new Meta.FileCryptoMetaData {
                EncryptionAlgorithm = new Meta.EncryptionAlgorithm {
                    AESGCMV1 = new Meta.AesGcmV1 {
                        AadFileUnique = fileUnique,
                        SupplyAadPrefix = false,
                        AadPrefix = Array.Empty<byte>()
                    }
                }
            };

            using MemoryStream ms = BuildStreamWithMetaAndEmptyEncryptedFooter(meta, keyBytes, aadPrefix: null, fileUnique: fileUnique);
            var w = new ThriftCompactProtocolWriter(ms);
            meta.Write(w);
            ms.Position = 0;

            var r = new ThriftCompactProtocolReader(ms);
            byte[] _ = EncryptionBase.DecryptFooter(r, keyString, aadPrefix: null, out EncryptionBase? _decr);
            Assert.NotNull(_decr);
        }

        [Fact]
        public void Utf8_16byte_Accepted() {
            string keyString = "1234567890abcdef"; // 16 bytes
            byte[] keyBytes = Encoding.UTF8.GetBytes(keyString);
            byte[] fileUnique = new byte[] { 9, 9, 9, 9 };

            var meta = new Meta.FileCryptoMetaData {
                EncryptionAlgorithm = new Meta.EncryptionAlgorithm {
                    AESGCMV1 = new Meta.AesGcmV1 {
                        AadFileUnique = fileUnique,
                        SupplyAadPrefix = false,
                        AadPrefix = Array.Empty<byte>()
                    }
                }
            };

            using MemoryStream ms = BuildStreamWithMetaAndEmptyEncryptedFooter(meta, keyBytes, aadPrefix: null, fileUnique: fileUnique);
            var w = new ThriftCompactProtocolWriter(ms);
            meta.Write(w);
            ms.Position = 0;

            var r = new ThriftCompactProtocolReader(ms);
            byte[] _ = EncryptionBase.DecryptFooter(r, keyString, aadPrefix: null, out EncryptionBase? _decr);
            Assert.NotNull(_decr);
        }

        [Theory]
        [InlineData("short")]                                 // 5 bytes UTF-8
        [InlineData("not-base64@@@@")]                       // invalid base64, not hex, len != 16/24/32
        [InlineData("AB")]                                   // 1 byte hex (odd length)
        [InlineData("00112233445566778899AABBCCDDEEFF00")]   // 17 bytes hex (34 chars)
        public void Invalid_Key_Formats_Throw(string key) {
            var meta = new Meta.FileCryptoMetaData {
                EncryptionAlgorithm = new Meta.EncryptionAlgorithm {
                    AESGCMV1 = new Meta.AesGcmV1 {
                        AadFileUnique = new byte[] { 1, 2, 3, 4 },
                        SupplyAadPrefix = false,
                        AadPrefix = Array.Empty<byte>()
                    }
                }
            };

            using var ms = new MemoryStream();
            var w = new ThriftCompactProtocolWriter(ms);
            meta.Write(w);
            ms.Position = 0;

            var r = new ThriftCompactProtocolReader(ms);

            Assert.Throws<ArgumentException>(() => {
                _ = EncryptionBase.DecryptFooter(r, key, aadPrefix: null, out EncryptionBase _);
            });
        }

        private static MemoryStream BuildStreamWithMetaAndEmptyEncryptedFooter(
    Meta.FileCryptoMetaData meta,
    byte[] key,
    byte[]? aadPrefix,
    byte[] fileUnique) {
            // 1) Serialize FileCryptoMetaData
            var ms = new MemoryStream();
            var w = new ThriftCompactProtocolWriter(ms);
            meta.Write(w);

            // 2) Build GCM-framed empty footer: len(=12+0+16) | nonce(12) | ciphertext(0) | tag(16)
            byte[] nonce = RandomNumberGenerator.GetBytes(12);
            byte[] tag = new byte[16];
            byte[] plaintext = Array.Empty<byte>();    // empty footer payload
            byte[] ciphertext = Array.Empty<byte>();   // empty since plaintext empty

            // AAD = aadPrefix || (fileUnique || moduleId(Footer))
            byte[] aadSuffix = fileUnique
                .Concat(new byte[] { (byte)ParquetModules.Footer })
                .ToArray();
            byte[] aad = (aadPrefix ?? Array.Empty<byte>()).Concat(aadSuffix).ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(key, 16);
#else
    using var gcm = new AesGcm(key);
#endif
            gcm.Encrypt(nonce, plaintext, ciphertext, tag, aad);

            int total = 12 + 0 + 16;
            ms.Write(BitConverter.GetBytes(total), 0, 4);
            ms.Write(nonce, 0, nonce.Length);
            ms.Write(tag, 0, tag.Length);

            ms.Position = 0;
            return ms;
        }

    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using Parquet.Encryption;
using Parquet.Meta;
using Parquet.Meta.Proto;
using Xunit;
using Encoding = System.Text.Encoding;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class MixedAlgorithmTests {
        private static readonly byte[] Key = Enumerable.Range(1, 32).Select(i => (byte)i).ToArray();
        private static readonly byte[] Prefix = Encoding.ASCII.GetBytes("mix");
        private static readonly byte[] Unique = new byte[] { 9, 9, 9, 9 };

        private static ThriftCompactProtocolReader R(byte[] buf) => new ThriftCompactProtocolReader(new MemoryStream(buf));

        private static byte[] FrameGcm(byte[] nonce12, byte[] ciphertext, byte[] tag16) {
            int len = nonce12.Length + ciphertext.Length + tag16.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            ms.Write(tag16, 0, tag16.Length);
            return ms.ToArray();
        }
        private static byte[] FrameCtr(byte[] nonce12, byte[] ciphertext) {
            int len = nonce12.Length + ciphertext.Length;
            using var ms = new MemoryStream();
            ms.Write(BitConverter.GetBytes(len), 0, 4);
            ms.Write(nonce12, 0, nonce12.Length);
            ms.Write(ciphertext, 0, ciphertext.Length);
            return ms.ToArray();
        }

        [Fact]
        public void PageHeader_GCM_and_Page_CTR_Both_Decrypt() {
            const short RG = 1, COL = 2, PAGE = 3;

            // --- Header (GCM) ---
            byte[] headerPlain = Encoding.ASCII.GetBytes("page-header-thrift");
            byte[] nonceH = RandomNumberGenerator.GetBytes(12);
            byte[] aadH = Prefix
                .Concat(Unique)
                .Concat(new byte[] { (byte)ParquetModules.Data_PageHeader })
                .Concat(BitConverter.GetBytes(RG))
                .Concat(BitConverter.GetBytes(COL))
                .Concat(BitConverter.GetBytes(PAGE))
                .ToArray();

#if NET8_0_OR_GREATER
            using var gcm = new AesGcm(Key, 16);
#else
            using var gcm = new AesGcm(Key);
#endif
            byte[] ctH = new byte[headerPlain.Length];
            byte[] tagH = new byte[16];
            gcm.Encrypt(nonceH, headerPlain, ctH, tagH, aadH);
            byte[] framedHeader = FrameGcm(nonceH, ctH, tagH);

            // --- Page (CTR) ---
            byte[] pagePlain = Encoding.ASCII.GetBytes("page-bytes-ctr");
            byte[] nonceP = RandomNumberGenerator.GetBytes(12);
            byte[] iv = new byte[16];
            Buffer.BlockCopy(nonceP, 0, iv, 0, 12);
            iv[12] = 0;
            iv[13] = 0;
            iv[14] = 0;
            iv[15] = 1;

            byte[] ctP;
            using(var aes = Aes.Create()) {
                aes.Mode = CipherMode.ECB;
                aes.Padding = PaddingMode.None;
                aes.Key = Key;
                using ICryptoTransform encryptor = aes.CreateEncryptor();
                ctP = XorCtr(encryptor, iv, pagePlain);
            }
            byte[] framedPage = FrameCtr(nonceP, ctP);

            var enc = new AES_GCM_CTR_V1_Encryption {
                DecryptionKey = Key,
                AadPrefix = Prefix,
                AadFileUnique = Unique
            };

            byte[] headerOut = enc.DecryptDataPageHeader(R(framedHeader), RG, COL, PAGE);
            byte[] pageOut = enc.DecryptDataPage(R(framedPage), RG, COL, PAGE);

            Assert.Equal(headerPlain, headerOut);
            Assert.Equal(pagePlain, pageOut);
        }

        private static byte[] XorCtr(ICryptoTransform ecbEncryptor, byte[] iv16, byte[] input) {
            byte[] counter = (byte[])iv16.Clone();
            byte[] output = new byte[input.Length];
            int i = 0;
            while(i < input.Length) {
                byte[] ks = new byte[16];
                ecbEncryptor.TransformBlock(counter, 0, 16, ks, 0);
                int n = Math.Min(16, input.Length - i);
                for(int j = 0; j < n; j++)
                    output[i + j] = (byte)(input[i + j] ^ ks[j]);
                for(int p = 15; p >= 12; p--)
                    if(++counter[p] != 0)
                        break;
                i += n;
            }
            return output;
        }
    }
}

using System;
using System.IO;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [CollectionDefinition(nameof(ParquetEncryptionTestCollection), DisableParallelization = true)]
    public class ParquetEncryptionTestCollection { }

    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class ParquetEncryptionTests : TestBase {
        private const string EncryptedFile = "encrypted_utf8_aes_gcm_v1_192bit.parquet";
        private const string CorrectKey = "QFwuIKG8yb845rEufVJAgcOo"; // from your test
        private const string WrongKey = "AAAAAAAAAAAAAAAAAAAAAAAA"; // same length, wrong bytes

        /// <summary>
        /// Happy path: decrypt the sample AES-GCM v1 (192-bit key) file and confirm we can read
        /// row group 0, all data fields, with non-empty values. This uses AADPrefix = null
        /// because the file does not require a supplied prefix.
        /// </summary>
        [Fact]
        public async Task Z_Decrypts_AESGCMv1_192bit_File_And_Reads_All_Columns() {
            using Stream stream = OpenTestFile(EncryptedFile);

            var parquetOptions = new ParquetOptions {
                EncryptionKey = CorrectKey,
                AADPrefix = null
            };

            using ParquetReader reader = await ParquetReader.CreateAsync(stream, parquetOptions);
            Assert.True(reader.RowGroupCount > 0);
            Assert.NotNull(reader.Schema);
            Assert.True(reader.Schema.DataFields.Length > 0);

            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);

            foreach(DataField df in reader.Schema.DataFields) {
                DataColumn dc = await rgr.ReadColumnAsync(df);

                // basic sanity checks that strongly imply successful decryption:
                Assert.Equal(df, dc.Field);
                Assert.True(dc.Data.Length > 0);

                // additional helpful checks for common text columns:
                if(df.ClrType == typeof(string)) {
                    string[] strings = (string[])dc.Data;
                    Assert.True(strings.Length > 0);
                    // ensure at least one non-null/non-empty string
                    Assert.Contains(strings, s => !string.IsNullOrEmpty(s));
                }
            }
        }

        /// <summary>
        /// Negative path: the same file with an incorrect key should throw when we attempt
        /// to read (either during footer decryption or the first column/page).
        /// We assert that some crypto/IO exception is raised.
        /// </summary>
        [Fact]
        public async Task Zz_Fails_With_Wrong_Key_On_AESGCMv1_File() {
            using Stream stream = OpenTestFile(EncryptedFile);

            var parquetOptions = new ParquetOptions {
                EncryptionKey = WrongKey,
                AADPrefix = null
            };

            // Creating the reader may already fail; if it doesn’t, reading the first column should.
            await Assert.ThrowsAnyAsync<Exception>(async () => {
                using ParquetReader reader = await ParquetReader.CreateAsync(stream, parquetOptions);
                using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
                DataField df = reader.Schema.DataFields[0];
                _ = await rgr.ReadColumnAsync(df);
            });
        }
    }
}

using System;
using System.IO;
using System.Text;
using Parquet.Encryption;
using Parquet.Meta.Proto;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class WriteFactoryTests {
        private static ThriftCompactProtocolReader R(Stream s) => new ThriftCompactProtocolReader(s);
        private static ThriftCompactProtocolWriter W(Stream s) => new ThriftCompactProtocolWriter(s);

        private static MemoryStream BuildFooterRegion(
            Meta.FileCryptoMetaData cryptoMeta,
            byte[] framedEncryptedFooter) {
            var ms = new MemoryStream();
            // [FileCryptoMetaData][framed encrypted footer]
            cryptoMeta.Write(W(ms));
            ms.Write(framedEncryptedFooter, 0, framedEncryptedFooter.Length);
            ms.Position = 0;
            return ms;
        }

        [Fact]
        public void Factory_Gcm_PrefixStored_RoundTripFooter() {
            string key = Convert.ToBase64String(new byte[16] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16 });
            byte[] prefix = Encoding.ASCII.GetBytes("stored-prefix");
            (EncryptionBase enc, Meta.FileCryptoMetaData? meta) = EncryptionBase.CreateEncrypterForWrite(
                encryptionKey: key,
                aadPrefixBytes: prefix,
                supplyAadPrefix: false,   // store in file
                useCtrVariant: false
            );

            // some plaintext footer bytes (would be a serialized FileMetaData in writer)
            byte[] footerPlain = Encoding.ASCII.GetBytes("tiny-footer");

            // encrypt
            byte[] framed = enc.EncryptFooter(footerPlain);

            // build an in-memory "footer region": meta + framed footer
            using MemoryStream region = BuildFooterRegion(meta, framed);

            // decrypt via the read-side factory
            byte[] decrypted = EncryptionBase.DecryptFooter(R(region), key, aadPrefix: null, out EncryptionBase? decr);
            Assert.Equal(footerPlain, decrypted);
        }

        [Fact]
        public void Factory_Gcm_PrefixSupplied_RoundTripFooter() {
            string key = Convert.ToBase64String(new byte[32] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32 });
            byte[] prefix = Encoding.ASCII.GetBytes("supply-me");

            (EncryptionBase enc, Meta.FileCryptoMetaData? meta) = EncryptionBase.CreateEncrypterForWrite(
                encryptionKey: key,
                aadPrefixBytes: prefix,
                supplyAadPrefix: true,   // do NOT store in file
                useCtrVariant: false
            );

            byte[] footerPlain = Encoding.ASCII.GetBytes("footer-AAD-supply");
            byte[] framed = enc.EncryptFooter(footerPlain);

            using MemoryStream region = BuildFooterRegion(meta, framed);

            // must supply prefix on decrypt
            byte[] decrypted = EncryptionBase.DecryptFooter(R(region), key, aadPrefix: Encoding.ASCII.GetString(prefix), out _);
            Assert.Equal(footerPlain, decrypted);
        }

        [Fact]
        public void Factory_CtrVariant_Still_GcmFooter_RoundTrip() {
            string key = "sixteen-byte-key"; // 16 bytes raw UTF-8
            byte[] prefix = Encoding.ASCII.GetBytes("ctr-variant");

            (EncryptionBase enc, Meta.FileCryptoMetaData? meta) = EncryptionBase.CreateEncrypterForWrite(
                encryptionKey: key,
                aadPrefixBytes: prefix,
                supplyAadPrefix: false,
                useCtrVariant: true   // CTR affects page bodies; footer remains GCM
            );

            byte[] footerPlain = Encoding.ASCII.GetBytes("footer-gcm-under-ctr");
            byte[] framed = enc.EncryptFooter(footerPlain);

            using MemoryStream region = BuildFooterRegion(meta, framed);

            byte[] decrypted = EncryptionBase.DecryptFooter(R(region), key, aadPrefix: null, out _);
            Assert.Equal(footerPlain, decrypted);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    [Collection(nameof(ParquetEncryptionTestCollection))]
    public class WriterFooterE2ETests : TestBase {

        private static ParquetSchema MakeSchema()
            => new ParquetSchema(new DataField<string>("s"));

        private static DataColumn MakeColumn(ParquetSchema schema, params string[] values) {
            var sField = (DataField)schema.Fields[0];   // field attached to the schema
            return new DataColumn(sField, values);
        }

        private static DataField[] SampleFields() =>
            new DataField[] { new DataField<string>("s") };

        private static DataColumn[] SampleColumns() =>
            new[] { MakeColumn(MakeSchema(), "a", "b", "c") };

        [Fact]
        public async Task A_FooterEncrypted_GcmV1_PrefixStored_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                EncryptionKey = Convert.ToBase64String(Enumerable.Range(1, 16).Select(i => (byte)i).ToArray()),
                AADPrefix = "stored-prefix"  // we’ll store it in file in CreateEncrypterForWrite
            };

            using var ms = new MemoryStream();
            // write
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(SampleColumns()[0]);
            }

            ms.Position = 0;

            // read back (no prefix needed because it’s stored in file)
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                EncryptionKey = opts.EncryptionKey,
                AADPrefix = null
            });
            Assert.True(reader.IsEncryptedFile);
            Assert.Equal(1, reader.RowGroupCount);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var dataField = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(dataField);
            Assert.Equal(new[] { "a", "b", "c" }, col.Data);
        }

        [Fact]
        public async Task B_FooterEncrypted_GcmV1_PrefixSupplied_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            string prefix = "supply-me";
            var opts = new ParquetOptions {
                EncryptionKey = Convert.ToBase64String(Enumerable.Range(1, 32).Select(i => (byte)i).ToArray()),
                AADPrefix = prefix   // we’ll mark SupplyAadPrefix=true in CreateEncrypterForWrite
            };

            // tell your writer path to use SupplyAadPrefix=true (e.g., via a bool in ParquetOptions or a small temp tweak)

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(SampleColumns()[0]);
            }

            ms.Position = 0;

            // must supply prefix on read
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                EncryptionKey = opts.EncryptionKey,
                AADPrefix = prefix
            });
            Assert.True(reader.IsEncryptedFile);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var dataField = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(dataField);
            Assert.Equal(new[] { "a", "b", "c" }, col.Data);
        }

        [Fact]
        public async Task C_FooterEncrypted_CtrVariant_FooterStillGcm_RoundTrip() {
            ParquetSchema schema = MakeSchema();
            var opts = new ParquetOptions {
                EncryptionKey = "sixteen-byte-key", // 16 bytes
                AADPrefix = "ctr-variant"
            };

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, formatOptions: opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(SampleColumns()[0]);
            }

            ms.Position = 0;

            using ParquetReader reader = await ParquetReader.CreateAsync(ms, new ParquetOptions {
                EncryptionKey = opts.EncryptionKey,
                AADPrefix = null // if stored; or same prefix if supply mode
            });
            Assert.True(reader.IsEncryptedFile);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var dataField = (DataField)reader.Schema.Fields[0];
            DataColumn col = await rgr.ReadColumnAsync(dataField);
            Assert.Equal(new[] { "a", "b", "c" }, col.Data);
        }
    }
}

using System;
using System.IO;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using Parquet.Data;
using Parquet.Meta;
using Parquet.Schema;
using Xunit;

namespace Parquet.Test.Encryption {
    public class WriterPageEncryptionTests : TestBase {
        private static ParquetOptions EncryptedOptions(string key, string? aadPrefix = null)
            => new ParquetOptions {
                EncryptionKey = key,      // 16/24/32 byte (or base64/hex) – we’ll use raw UTF-8 16B below
                AADPrefix = aadPrefix     // null = prefix stored in file when writer sets supplyAadPrefix=false
            };

        [Fact]
        public async Task A_WriteEncrypted_GcmFooterKey_RoundTrip_ReadsBack() {
            // Arrange: simple schema & data
            var schema = new ParquetSchema(new DataField<string>("name"));
            var col = new DataColumn((DataField)schema.Fields[0], new[] { "a", "b", "c", "d" });

            // 16B key (AES-128) as raw UTF-8; spec requires 16/24/32B after parsing
            ParquetOptions opts = EncryptedOptions("footerKey-16byte", aadPrefix: null);

            using var ms = new MemoryStream();

            // Act: write encrypted
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                // For this step we store the AAD prefix in the file (writer default: supplyAadPrefix=false)
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(col);
            }

            // Read back
            ms.Position = 0;
            using ParquetReader reader = await ParquetReader.CreateAsync(ms, opts);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            var df = (DataField)reader.Schema.Fields[0];
            DataColumn readCol = await rgr.ReadColumnAsync(df);

            // Assert: values round-trip
            string[] actual = readCol.Data.Cast<string>().AsEnumerable<string>().ToArray();
            Assert.Equal(new[] { "a", "b", "c", "d" }, actual);
        }

        [Fact]
        public async Task B_WriterSets_CryptoMetadata_OnEncryptedColumnChunks() {
            // Arrange
            var schema = new ParquetSchema(
                new DataField<int>("id"),
                new DataField<string>("s")
            );

            var id = new DataColumn((DataField)schema.Fields[0], new[] { 1, 2, 3 });
            var s = new DataColumn((DataField)schema.Fields[1], new[] { "x", "y", "z" });

            ParquetOptions opts = EncryptedOptions("footerKey-16byte", aadPrefix: null);

            using var ms = new MemoryStream();

            // Act: write encrypted
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(id);
                await rg.WriteColumnAsync(s);
            }

            // Assert: the column chunks are marked as footer-key encrypted
            ms.Position = 0;
            var actor = new ParquetActor(ms);
            await actor.ValidateFileAsync(); // sets IsEncryptedFile when PARE magic present

            FileMetaData meta = await actor.ReadMetadataAsync(
                decryptionKey: opts.EncryptionKey,
                aadPrefix: opts.AADPrefix
            );

            Assert.NotNull(meta.RowGroups);
            Assert.Single(meta.RowGroups);

            RowGroup rowGroup = meta.RowGroups[0];
            Assert.Equal(2, rowGroup.Columns.Count);

            foreach(ColumnChunk chunk in rowGroup.Columns) {
                Assert.NotNull(chunk.CryptoMetadata);
                Assert.NotNull(chunk.CryptoMetadata!.ENCRYPTIONWITHFOOTERKEY);
                Assert.Null(chunk.CryptoMetadata.ENCRYPTIONWITHCOLUMNKEY);
            }
        }

        private static string RandomB64Key(int bytes = 16) =>
            Convert.ToBase64String(RandomNumberGenerator.GetBytes(bytes));

        [Theory]
        [InlineData(false)] // AES-GCM-V1
        [InlineData(true)]  // AES-GCM-CTR-V1
        public async Task Encrypted_WithDictionary_ThenDataPage_RoundTrips(bool useCtr) {
            var field = new DataField<string>("s");
            var schema = new ParquetSchema(field);

            var opts = new ParquetOptions {
                // 128-bit key (Base64)
                EncryptionKey = RandomB64Key(16),
                // store the prefix in the file (no external supply)
                AADPrefix = null,
                SupplyAadPrefix = false,
                UseCtrVariant = useCtr,
                // force dictionary and a very small threshold so dictionary is definitely used
                UseDictionaryEncoding = true,
                DictionaryEncodingThreshold = 1.0
            };

            // Highly repetitive values to ensure a dictionary page is emitted.
            string[] values = Enumerable.Repeat("aaaa", 1000).ToArray();

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(new DataColumn(field, values));
            }

            ms.Position = 0;

            using ParquetReader reader = await ParquetReader.CreateAsync(ms, opts);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            DataColumn col = await rgr.ReadColumnAsync(field);

            Assert.Equal(values.Length, col.Data.Length);
            Assert.All<object>(col.Data.Cast<object>(), v => Assert.Equal("aaaa", (string)v!));
        }

        [Theory]
        [InlineData(false)]
        [InlineData(true)]
        public async Task Encrypted_NoDictionary_DataPageOrdinalStillStartsAtZero(bool useCtr) {
            var field = new DataField<int>("x");
            var schema = new ParquetSchema(field);

            var opts = new ParquetOptions {
                EncryptionKey = RandomB64Key(16),
                AADPrefix = null,
                SupplyAadPrefix = false,
                UseCtrVariant = useCtr,
                // Disable dictionary to ensure no dict page; first data page should be ordinal 0.
                UseDictionaryEncoding = false
            };

            int[] data = Enumerable.Range(0, 256).ToArray();

            using var ms = new MemoryStream();
            using(ParquetWriter writer = await ParquetWriter.CreateAsync(schema, ms, opts)) {
                using ParquetRowGroupWriter rg = writer.CreateRowGroup();
                await rg.WriteColumnAsync(new DataColumn(field, data));
            }

            ms.Position = 0;

            using ParquetReader reader = await ParquetReader.CreateAsync(ms, opts);
            using ParquetRowGroupReader rgr = reader.OpenRowGroupReader(0);
            DataColumn col = await rgr.ReadColumnAsync(field);

            Assert.Equal(data, col.Data);
        }
    }
}